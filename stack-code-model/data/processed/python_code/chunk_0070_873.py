package worlds 
{
	import net.flashpunk.Sfx;
	import objects.Bubbly;
	import objects.Food;
	import objects.HudgeBubble;
	import objects.LandingNet;
	import hud.ShitFilter;
	import hud.BoostBar;
	import flash.utils.Dictionary;
	import net.flashpunk.Entity;
	import net.flashpunk.FP;
	import util.TextManager;
	import util.MusicPlayer;
	import util.EntitySpawner;
	
	/**
	 * ...
	 * @author Mathieu Capdegelle & Adrien Cuisinier
	 */
	public class Game extends Scene 
	{
		public static const BUBBLE_COUNT_MIN:int = 3;
		public static const BUBBLE_COUNT_MAX:int = 5;
		
		public static const FOOD_COUNT_MIN:int = 2;
		public static const FOOD_COUNT_MAX:int = 5;
		
		public static const BOOST_TIME_TO_WIN:Number = 20;
		
		public static const MAX_SPEED_RATE:Number = 1.8;
		public static const MAX_SPEED_RATE_TIME:Number = 120;
		
		public static const GIRL_YELLS_COUNT:int = 4;
		
		// hud
		private var _boostBar:BoostBar;
		private var _textManager:TextManager;
		private var _shitFilter:ShitFilter;
		
		// actors
		private var _bubbly:Bubbly;
		private var _landingNet:LandingNet;
		
		// game parameters
		private var _randomEntityGroups:Dictionary;
		public static var speedRate:Number = 1;
		private var _totalElaspedTime:Number = 0;
		private var _shitFilterOpacity:Number = 0;
		private var _girlYellIndex:int = 0;
		private var _trackTwo:Boolean = false;
		
		public function Game() 
		{
			super(Assets.SCENE_GAME);
			
			_textManager = new TextManager();
			_boostBar = new BoostBar();
			_shitFilter = new ShitFilter();
			
			_bubbly = new Bubbly();
			_landingNet = new LandingNet();

			_randomEntityGroups = new Dictionary();
		}
		
		override public function begin():void 
		{
			super.begin();
			
			speedRate = 1;
			
			MusicPlayer.crossFadeToTrack(Assets.SOUND_GAME1_INTRO, 1, false, function():void { 
				MusicPlayer.playTrack(Assets.SOUND_GAME1_LOOP, 0, true)} 
			);
			
			add(_boostBar);
			add(_shitFilter);
			add(_textManager);
			
			_bubbly.x = FP.halfWidth - Bubbly.WIDTH / 2;
			_bubbly.y = FP.halfHeight - Bubbly.HEIGHT / 2;
			
			add(_bubbly);
			_bubbly.startSwimming();

			add(_landingNet);	
			
			_landingNet.x = (_bubbly.x - FP.width / 2) - LandingNet.WIDTH_FRONT / 2;
			FP.camera.x = _bubbly.x - FP.halfWidth + Bubbly.WIDTH / 2;
		}
		
		override public function update():void 
		{
			super.update();
			
			_totalElaspedTime += FP.elapsed;
			
						
			// detect game ending
			if (_bubbly.collide("landingnet", _bubbly.x, _bubbly.y))
			{
				_bubbly.stopFartSound(); // quick fix
				FP.world = new GameOver(false);
				return;
			}
			
			if (_bubbly.totalTimeUsingBoost >= BOOST_TIME_TO_WIN)
			{
				_bubbly.stopFartSound(); // quick fix
				FP.world = new GameOver(true);
				return;
			}
			
			FP.camera.x = _bubbly.x - FP.halfWidth + Bubbly.WIDTH / 2;
			
			// shitification of the screen
			if (_shitFilterOpacity < 1)
			{
				_shitFilterOpacity = int(_bubbly.totalTimeUsingBoost) / BOOST_TIME_TO_WIN;
			}

			// music transition detection
			if (!_trackTwo && (
					_totalElaspedTime / MAX_SPEED_RATE_TIME > 0.5 ||
					_bubbly.totalTimeUsingBoost / BOOST_TIME_TO_WIN > 0.5
				))
			{
				_trackTwo = true;
				
				//transition musique
				MusicPlayer.crossFadeToTrack(Assets.SOUND_GAME2_INTRO, 2, false, function():void { 
					MusicPlayer.playTrack(Assets.SOUND_GAME2_LOOP, 0, true)} 
				);
			}
			
			// progressive game speed acceleration
			if (speedRate < MAX_SPEED_RATE) 
			{
				speedRate += FP.elapsed * (MAX_SPEED_RATE - 1) / MAX_SPEED_RATE_TIME;
				if (speedRate > MAX_SPEED_RATE) {
					speedRate = MAX_SPEED_RATE;
				}
			}
			
			// girl yells
			if ( _girlYellIndex < GIRL_YELLS_COUNT &&
				_bubbly.totalTimeUsingBoost / BOOST_TIME_TO_WIN >= (_girlYellIndex + 1) / (GIRL_YELLS_COUNT + 1))
			{
				_textManager.ShoxDialog(_girlYellIndex);
				var voiceSfx:Sfx = new Sfx(Assets.GIRL_YELLS_SOUNDS[_girlYellIndex]);
				voiceSfx.play();
				
				_girlYellIndex++;
			}
		}
		
		override protected function OnEntitiesAddedFromGrid(index:int, x:int):void 
		{
			_randomEntityGroups[index] = 
				EntitySpawner.RandomSpawn(x, 0, 
					x + FP.width - HudgeBubble.WIDTH - 20, 
					FP.width - HudgeBubble.HEIGHT - 20, 
					BUBBLE_COUNT_MIN, BUBBLE_COUNT_MAX,
					function ():Entity { return new HudgeBubble() })
				.concat(
					EntitySpawner.RandomSpawn(x, 0, 
					x + FP.width - Food.FOOD_WIDTH - 20, 
					FP.width - Food.FOOD_HEIGHT - 20, 
					FOOD_COUNT_MIN, FOOD_COUNT_MAX,
					function ():Entity { return new Food() } )
				);
		}
				
		override protected function OnEntitiesRemovedFromGrid(index:int, x:int):void 
		{
			//deletion of all autogenerated bubbles when the owner grid is destroyed
			var entities:Vector.<Entity> = (_randomEntityGroups[index] as Vector.<Entity>);
			for each(var entity:Entity in entities)
				remove(entity);			
			
			delete _randomEntityGroups[index];
		}
		
		override public function render():void 
		{
			super.render();
			_shitFilter.SetAlpha(_shitFilterOpacity);
		}
		
		public function get boostBar():BoostBar
		{
			return _boostBar;
		}
	}

}