package gs.util.iters{	/**	 * The ArrayBidirectionalIterator class provides a non-destructive,	 * pointer-based, bi-directional array iterator.	 */	public class ArrayBidirectionalIterator	{		/**		 * @private		 */		protected var _array:Array;				/**		 * @private		 */		protected var _pointer:int;		/**		 * Constructor for ArrayBidirectionalIterator instances.		 * 		 * @param array The array to iterate over.		 * @param copy Whether or not to copy the source array.		 */		public function ArrayBidirectionalIterator(array:Array,copy:Boolean=true) 		{			if(copy)_array=array.concat();			else _array=array;			reset();		}		/**		 * The previous element, or null.		 */		public function previous():Object		{			_pointer--;			if(_pointer==-1)			{				trace("WARNING: Cursor is out of bounds, you should use hasPrevious() before calling previous(). Returning null.");				return null;			}			return _array[_pointer];		}		/**		 * The next element, or null.		 */		public function next():Object		{			_pointer++;			if(_pointer==_array.length)			{				trace("WARNING: Cursor is out of bounds, you should use hasNext() before calling next(). Returning null.");				return null;			}			return _array[_pointer];		}				/**		 * The current element.		 */		public function current():Object		{			return _array[_pointer];		}		/**		 * Resets the pointer.		 */		public function reset():void		{			_pointer=-1;		}		/**		 * Check if iterator has a previous element.		 */		public function hasPrevious():Boolean		{			return (_pointer>0);		}			/**		 * Check if iterator has a next element.		 */		public function hasNext():Boolean		{			return (_pointer<_array.length-1);		}		/**		 * Return a glimpse of the previous element without 		 * updating the array element pointer, or <code>null</code>.		 */		public function glimpse():Object		{			var t:int=_pointer-1;			if(t > -1)return _array[t];			else trace("WARNING: Cursor out of bounds, you should use hasNext or hasPrevious. Returning null.");			return null;		}				/**		 * Return a peek of the next element without 		 * updating the array element pointer, or <code>null</code>.		 */		public function peek():Object		{			var t:int=_pointer+1;			if(t<_array.length) return _array[t];			else trace("WARNING: Cursor out of bounds, you should use hasNext or hasPrevious. Returning null.");			return null; 		}		/**		 * The collection length.		 */		public function get length():int		{			return _array.length;		}				/**		 * Dispose of this iterator.		 */		public function dispose():void		{			_pointer=0;			_array=null;		}	}}