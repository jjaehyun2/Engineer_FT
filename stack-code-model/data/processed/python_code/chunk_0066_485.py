/** * * MetaBalls * * https://github.com/AbsolutRenal * * Copyright (c) 2012 AbsolutRenal (Renaud Cousin). All rights reserved. *  * This ActionScript source code is free. * You can redistribute and/or modify it in accordance with the * terms of the accompanying Simplified BSD License Agreement.**/package com.absolut.geometry{	import com.absolut.utils.calculateCircleTangentePointFromPoint;	import com.absolut.datas.Config;	import com.absolut.utils.calculateAngleFromCoef;	import com.absolut.utils.calculateCirclesIntersections;	import com.absolut.utils.calculateCoefFromPoints;	import com.absolut.utils.calculateIntersectionsFromCircleCenter;	import com.absolut.utils.calculateLinesIntersection;	import com.absolut.utils.checkCirclesCollision;	import com.absolut.utils.checkCirclesCollisionButNotIncluded;	import com.absolut.utils.degToRad;	import com.absolut.utils.drawLine;	import com.absolut.utils.drawPoint;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.text.TextField;	import flash.text.TextFormat;		[SWF(backgroundColor="#FFFFFF", frameRate="31", width="1024", height="768")]	public class Metaballs extends Sprite{		private const RADIUS_MIN:int = 20;		private const RADIUS_RANGE:int = 100;				private var radiusAmount:int = 0;		private var stageRect:Rectangle;		private var circleContainer:Sprite;		private var circle1:Sprite;		private var circle2:Sprite;		private var zone:Sprite;		private var dragginItem:Sprite;		private var lineContainer:Sprite;		private var textDebugger:TextField;				public function Metaballs(){			init();			initDebug();			active();						dragginItem = circle1;			render(null);		}						private function init():void{			stageRect = new Rectangle(0, 0, stage.stageWidth, stage.stageHeight);						circleContainer = new Sprite();			addChild(circleContainer);						var radius:int = RADIUS_MIN + Math.random() * RADIUS_RANGE;			radiusAmount += radius;						circle1 = new Sprite();			zone = new Sprite();			if(Config.SHOW_WORKING_LINES){				circle1.graphics.lineStyle(1, 0);				circle1.graphics.drawCircle(0, 0, radius);				circle1.graphics.moveTo(0, -4);				circle1.graphics.lineTo(0, 5);				circle1.graphics.moveTo(-4, 0);				circle1.graphics.lineTo(5, 0);				zone.alpha = .1;			}			zone.graphics.beginFill(0x000000);			zone.graphics.drawCircle(0, 0, radius);			zone.graphics.endFill();			circle1.addChild(zone);			circle1.x = 350;			circle1.y = 300;			circleContainer.addChild(circle1);						radius = RADIUS_MIN + Math.random() * RADIUS_RANGE;			radiusAmount += radius;									circle2 = new Sprite();			zone = new Sprite();			if(Config.SHOW_WORKING_LINES){				circle2.graphics.lineStyle(1, 0);				circle2.graphics.drawCircle(0, 0, radius);				circle2.graphics.moveTo(0, -4);				circle2.graphics.lineTo(0, 5);				circle2.graphics.moveTo(-4, 0);				circle2.graphics.lineTo(5, 0);				zone.alpha = .1;			}			zone.graphics.beginFill(0x000000);			zone.graphics.drawCircle(0, 0, radius);			zone.graphics.endFill();			circle2.addChild(zone);			circle2.x = 600;			circle2.y = 300;			circleContainer.addChild(circle2);		}				private function initDebug():void{			if(Config.SHOW_WORKING_LINES){				lineContainer = new Sprite();				lineContainer.mouseEnabled = false;				addChild(lineContainer);								var tf:TextFormat = new TextFormat();				tf.size = 10;				tf.leading = -5;								textDebugger = new TextField();				textDebugger.multiline = true;				textDebugger.wordWrap = true;				textDebugger.width = 400;				textDebugger.height = stage.stageHeight;				textDebugger.defaultTextFormat = tf;				addChildAt(textDebugger, 0);			}		}				private function debug(msg:String):void{			if(Config.SHOW_WORKING_LINES){				msg = msg.replace("[DEBUG]", "<font color='#FF0000'>[DEBUG]</font>");				msg = msg.replace("[INFO]", "<font color='#00FF00'>[INFO]</font>");				msg = msg.replace("[XXX]", "<font color='#0000FF'>[XXX]</font>");				textDebugger.htmlText += "<br />" + msg;				textDebugger.scrollV = textDebugger.numLines;				if(textDebugger.numLines > 10){					textDebugger.htmlText = textDebugger.htmlText.replace(textDebugger.getLineText(1), "");				}			}		}				private function active():void{			circle1.mouseChildren = circle2.mouseChildren = false;			circleContainer.buttonMode = true;			circleContainer.addEventListener(MouseEvent.MOUSE_DOWN, startDraggin);			stage.addEventListener(MouseEvent.MOUSE_UP, stopDraggin);		}				private function startDraggin(e:MouseEvent):void{			dragginItem = e.target as Sprite;			dragginItem.startDrag(false, stageRect);						addEventListener(Event.ENTER_FRAME, render);		}				private function stopDraggin(e:MouseEvent):void{			if(dragginItem){				dragginItem.stopDrag();				dragginItem = null;			}						removeEventListener(Event.ENTER_FRAME, render);		}				private function render(e:Event):void{			graphics.clear();									if(Config.SHOW_WORKING_LINES){				if(checkCirclesCollision(circle1, circle2))					dragginItem.alpha = .2;				else					dragginItem.alpha = 1;			}						// CENTER CIRCLE 1			var center1:Point = new Point(circle1.x, circle1.y);						// CENTER CIRCLE 2			var center2:Point = new Point(circle2.x, circle2.y);						// COEF DIRECTEUR CENTER1-CENTER2			var centersCoef:Number = calculateCoefFromPoints(center1, center2);//			debug("[DEBUG] CENTERS_COEF:" + centersCoef.toString());			// COEF DIRECTEUR PERPENDICULAIRE CENTER1-CENTER2 => INTERSECTION1-INTERSECTION2			var coefPerpendicular:Number = -1/centersCoef;						// ANGLE INTERSECTION1-INTERSECTION2			var angleDeg:Number = calculateAngleFromCoef(coefPerpendicular, center1, center2, true);//			debug("[DEBUG] ANGLE PERPENDICULAIRE:" + angleDeg.toString());			var angleRad:Number = degToRad(angleDeg);						var intersection:Array = calculateIntersectionsFromCircleCenter(circle1, angleRad);			var intersect1:Point = intersection[0] as Point;			var intersect2:Point = intersection[1] as Point;			intersection = calculateIntersectionsFromCircleCenter(circle2, angleRad);			var intersect3:Point = intersection[0] as Point;			var intersect4:Point = intersection[1] as Point;			// FIRST STEP //						var coef1:Number = calculateCoefFromPoints(intersect1, intersect3);			var coef2:Number = calculateCoefFromPoints(intersect2, intersect4);			var tangentesIntersections:Point = calculateLinesIntersection(intersect1, coef1, intersect2, coef2);						// SECOND STEP //			var circlesIntersect:Vector.<Point>;			if(checkCirclesCollisionButNotIncluded(circle1, circle2)){				circlesIntersect = calculateCirclesIntersections(circle1, circle2);				var tangentes1:Vector.<Point> = calculateCircleTangentePointFromPoint(circle1, tangentesIntersections);				var tangentes2:Vector.<Point> = calculateCircleTangentePointFromPoint(circle2, tangentesIntersections);								if(!Config.SHOW_WORKING_LINES){					graphics.beginFill(0x000000);				} else {					graphics.beginFill(0xA00AA0, .2);//					graphics.lineStyle(1, 0xA00AA0);//					graphics.moveTo(tangentes1[&&(§0].x, tangentes1[0].y);//					graphics.lineTo(tangentes2[0].x, tangentes2[0].y);//					graphics.lineTo(tangentes2[1].x, tangentes2[1].y);//					graphics.lineTo(tangentes1[1].x, tangentes1[1].y);//					graphics.lineTo(tangentes1[0].x, tangentes1[0].y);//					graphics.endFill();				}				graphics.moveTo(tangentes1[0].x, tangentes1[0].y);				graphics.curveTo(circlesIntersect[0].x, circlesIntersect[0].y, tangentes2[0].x, tangentes2[0].y);				graphics.lineTo(tangentes2[1].x, tangentes2[1].y);				graphics.curveTo(circlesIntersect[1].x, circlesIntersect[1].y, tangentes1[1].x, tangentes1[1].y);				graphics.lineTo(tangentes1[0].x, tangentes1[0].y);				graphics.endFill();			}									// SECOND STEP //						if(Config.SHOW_WORKING_LINES){				lineContainer.graphics.clear();				drawLine(lineContainer, center1, center2, 0x08FF80, 2, 3, false);				//				drawLine(lineContainer, intersect1, intersect2, 0x0000FF, 2, 3, true);				drawLine(lineContainer, intersect3, intersect4, 0x0000FF, 2, 3, true);				drawLine(lineContainer, intersect1, tangentesIntersections, 0xCA080A);				drawLine(lineContainer, intersect2, tangentesIntersections, 0xCA080A);				drawLine(lineContainer, intersect1, intersect3, 0xCA080A);				drawLine(lineContainer, intersect2, intersect4, 0xCA080A);				//				drawPoint(lineContainer, tangentesIntersections, 3, 0x00AA00);				lineContainer.graphics.lineStyle(1, 0x00AA00);				lineContainer.graphics.drawCircle(tangentesIntersections.x + (center1.x - tangentesIntersections.x) * .5, tangentesIntersections.y + (center1.y - tangentesIntersections.y) * .5, Point.distance(center1, tangentesIntersections) * .5);								if(circlesIntersect != null){					drawPoint(lineContainer, circlesIntersect[0], 2, 0xFFAA00);					drawPoint(lineContainer, circlesIntersect[1], 2, 0xFFAA00 << 16);					//					drawPoint(lineContainer, tangentes1[0], 4, 0xF3F003);					drawPoint(lineContainer, tangentes1[1], 4, 0xF3F003 << 16);					drawPoint(lineContainer, tangentes2[0], 4, 0xF3F003);					drawPoint(lineContainer, tangentes2[1], 4, 0xF3F003 << 16);				}				////				drawLine(lineContainer, intersect5, center1, 0xFF0000, 3, true);//				drawLine(lineContainer, intersect6, center1, 0xFF0000, 3, true);//				drawLine(lineContainer, intersect7, center2, 0xFF0000, 3, true);//				drawLine(lineContainer, intersect8, center2, 0xFF0000, 3, true);//				drawLine(lineContainer, intersect5, intersect7, 0xFF0000, 3, false);//				drawLine(lineContainer, intersect6, intersect8, 0xFF0000, 3, false);			}		}	}}