package src.game{	import Box2D.Collision.Shapes.b2PolygonShape;	import Box2D.Common.Math.b2Vec2;	import Box2D.Dynamics.Contacts.b2Contact;	import Box2D.Dynamics.Contacts.b2ContactEdge;	import Box2D.Dynamics.Joints.b2Joint;	import Box2D.Dynamics.Joints.b2RevoluteJointDef;	import Box2D.Dynamics.b2Body;	import Box2D.Dynamics.b2BodyDef;	import Box2D.Dynamics.b2FilterData;	import Box2D.Dynamics.b2FixtureDef;	import Box2D.Dynamics.b2World;	import box2dassets.Box;	import caurina.transitions.Tweener;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.ui.Keyboard;	import net.fpp.common.achievement.AchievementManager;	import net.fpp.common.starling.StaticAssetManager;	import net.fpp.common.starling.log.LogModule;	import rv2.sound.SoundHandler;	import src.AbstractPanel;	import src.assets.CarDatas;	import src.assets.Levels;	import src.assets.TerrainTextures;	import src.common.TasksManager;	import src.constant.CBox2D;	import src.constant.CGameEffect;	import src.constant.CGameTimeValues;	import src.constant.CLibraryElement;	import src.constant.CScore;	import src.data.CarData;	import src.data.Level;	import src.data.LevelEndVO;	import src.data.LibraryElementVO;	import src.data.PlayerData;	import src.game.background.BackgroundVO;	import src.game.events.GameEvent;	import src.game.events.GameGuiEvent;	import src.game.library.crates.BaseCrate;	import src.game.library.crates.Crate;	import src.game.library.crates.LongCrate;	import src.game.library.crates.RampCrate;	import src.game.library.crates.SmallCrate;	import src.game.library.crates.SmallLongCrate;	import src.game.library.crates.SmallRampCrate;	import src.game.module.notification.constant.CNotification;	import src.game.module.snow.SnowModule;	import src.menu.events.MenuEvent;	import src.utils.BrushPattern;	import starling.core.Starling;	import starling.display.Image;	import starling.display.MovieClip;	import starling.display.Sprite;	import starling.events.Event;	import starling.events.KeyboardEvent;	import starling.events.Touch;	import starling.events.TouchEvent;	import starling.events.TouchPhase;	import starling.textures.Texture;	public class Game extends AbstractPanel	{		// box2d assets		private var _world:b2World;		private var _car:ExtendedCar;		private var _mapElements:Vector.<b2Body> = new Vector.<b2Body>;		private var _b2Joints:Vector.<b2Joint> = new Vector.<b2Joint>;		private var _bridgeElements:Vector.<Vector.<BridgeElement>> = new Vector.<Vector.<BridgeElement>>;		private var _bridgeB2Bodies:Vector.<Vector.<b2Body>> = new Vector.<Vector.<b2Body>>;		// camera		private const CAMERA_EASE:Point = new Point( 10, 10 );		private var _cameraOffset:Point = new Point;		private var _camera:Point = new Point;		private var _lastCameraStepOffset:Point = new Point;		private var _container:Sprite;		private var _terrainContainer:Sprite;		private var _coinContainer:Sprite;		private var _libraryElementContainer:Sprite;		// game objects		private var _gameGui:GameGui;		private var _controlLeft:Image;		private var _controlRight:Image;		private var _controlUp:Image;		private var _controlDown:Image;		private var _carBody:Image;		private var _wheelRight:Image;		private var _wheelLeft:Image;		private var _snowModule:SnowModule;		private var _startCounter:StartCounter;		private var _achievementManager:AchievementManager;		private var _smallRocks:Vector.<Image> = new Vector.<Image>;		private var _usedSmallRocks:Vector.<Image> = new Vector.<Image>;		private var _gameObjects:Vector.<Image> = new Vector.<Image>;		private var _terrains:Vector.<Image> = new Vector.<Image>;		private var _effects:Vector.<Image> = new Vector.<Image>;		private var _coins:Vector.<Coin> = new Vector.<Coin>;		private var _crates:Vector.<BaseCrate> = new Vector.<BaseCrate>;		private var _backgroundVOs:Vector.<BackgroundVO> = new Vector.<BackgroundVO>;		// level variables		private var _levelData:Level;		private var _levelID:uint;		private var _worldID:uint;		// controllers		private var _left:Boolean;		private var _right:Boolean;		private var _up:Boolean;		private var _down:Boolean;		protected var _gameTime:Number = 0;		private var _gameStartTime:Number = 0;		private var _pauseStartTime:Number = 0;		private var _totalPausedTime:Number = 0;		private var _collectedCoin:uint = 0;		private var _collectedExtraCoins:uint = 0;		private var _countOfFrontFlip:uint = 0;		private var _countOfBackFlip:uint = 0;		private var _countOfNiceWheelie:uint = 0;		private var _countOfNiceAirTime:uint = 0;		private var _isLost:Boolean;		private var _isWon:Boolean;		private var _canControll:Boolean;		private var _isGameStarted:Boolean;		public function Game( levelID:uint, worldID:uint ):void		{			this._levelID = Math.min( levelID, Levels.levels[ worldID ].length );			this._worldID = worldID;			this._achievementManager = TasksManager.getAchievementManagerByWorld( this._worldID );			this._levelData = Levels.levels[ worldID ][ levelID ];			this.addEventListener( Event.ADDED_TO_STAGE, this.loaded );		}		private function loaded( event:Event ):void		{			removeEventListener( Event.ADDED_TO_STAGE, loaded );			_cameraOffset = new Point( -1 * ( stage.stageWidth / 2 - 100 ), -1 * ( stage.stageHeight / 2 + 25 ) );			this.addBackground( 'back_world_' + this._worldID + '_a', 50, new Point( .1, .1 ), -.5, 1.1 );			this.addBackground( 'back_world_' + this._worldID + '_b', 100, new Point( .35, .35 ), -.5, 1.1 );			addChild( _container = new Sprite );			_world = new b2World( new b2Vec2( 0, CBox2D.GRAVITY ), true );			createGroundPhysics( _levelData.groundPoints );			// generate small rocks			for( i = 0; i < 30; i++ )			{				_smallRocks.push( _container.addChild( new Image( StaticAssetManager.instance.getTexture( "small_rock_" + _worldID + '_' + Math.floor( Math.random() * 3 + 1 ) ) ) as Image ) );				_smallRocks[ _smallRocks.length - 1 ].visible = false;				_smallRocks[ _smallRocks.length - 1 ].pivotX = _smallRocks[ _smallRocks.length - 1 ].width / 2;				_smallRocks[ _smallRocks.length - 1 ].pivotY = _smallRocks[ _smallRocks.length - 1 ].height / 2;				_smallRocks[ _smallRocks.length - 1 ].touchable = false;			}			// create game objects			for( i = 0; i < _levelData.gameObjects.length; i++ )			{				_gameObjects.push( _container.addChild( new Image( StaticAssetManager.instance.getTexture( _levelData.gameObjects[ i ].texture ) ) as Image ) );				_gameObjects[ _gameObjects.length - 1 ].pivotX = _levelData.gameObjects[ i ].pivotX;				_gameObjects[ _gameObjects.length - 1 ].pivotY = _levelData.gameObjects[ i ].pivotY;				_gameObjects[ _gameObjects.length - 1 ].x = _levelData.gameObjects[ i ].x;				_gameObjects[ _gameObjects.length - 1 ].y = _levelData.gameObjects[ i ].y;				_gameObjects[ _gameObjects.length - 1 ].rotation = _levelData.gameObjects[ i ].rotation;				_gameObjects[ _gameObjects.length - 1 ].touchable = false;			}			// process map terrain			_mapElements.push( createBox( "WALL", 0, 0, 10, 1200, false, true, 1, 1, 0 ) );			_mapElements.push( createBox( "WALL", _levelData.maxWidth, 0, 10, 1200, false, true, 1, 1, 0 ) );			this.createBridges();			this.addLibraryElements();			var terrainGroundTexture:BitmapData = TerrainTextures.getLevelPackTerrainGroundTexture( _worldID );			var terrainFillTexture:BitmapData = TerrainTextures.getLevelPackTerrainFillTexture( _worldID );			try			{				// Create world pieces				_container.addChild( _terrainContainer = new Sprite );				_terrainContainer.touchable = false;				var generatedTerrain:BrushPattern = new BrushPattern( _levelData.groundPoints, terrainGroundTexture, terrainFillTexture, 64, 24 );				var maxBlockSize:uint = 2048;				var pieces:uint = Math.ceil( generatedTerrain.width / maxBlockSize );				for( var i:uint = 0; i < pieces; i++ )				{					var tmpBitmapData:BitmapData = new BitmapData( maxBlockSize, maxBlockSize, true, 0x60 );					var offsetMatrix:Matrix = new Matrix;					offsetMatrix.tx = -i * maxBlockSize;					tmpBitmapData.draw( generatedTerrain, offsetMatrix );					_terrains.push( new Image( Texture.fromBitmap( new Bitmap( tmpBitmapData ), false, false, 2 ) ) );					_terrains[ i ].x = i * maxBlockSize / 2;					_terrains[ i ].touchable = false;					_terrainContainer.addChild( _terrains[ i ] );					tmpBitmapData.dispose();					tmpBitmapData = null;				}			}catch( e:Error )			{				if( MountainMonsterIOSMain.LOG_ENABLED )				{					LogModule.add( 'Terrain generation error: ' + e.getStackTrace() );				}				this.dispatchEvent( new GameEvent( GameEvent.RESOURCE_LIMIT_ERROR ) );				return;			}			terrainGroundTexture.dispose();			terrainGroundTexture = null;			terrainFillTexture.dispose();			terrainFillTexture = null;			generatedTerrain.dispose();			generatedTerrain = null;			// Add coins			_container.addChild( _coinContainer = new Sprite );			for( i = 0; i < _levelData.coinPoints.length; i++ )			{				addCoinToWorld( _levelData.coinPoints[ i ].x, _levelData.coinPoints[ i ].y );			}			// add control buttons			addChild( _controlLeft = new Image( StaticAssetManager.instance.getTexture( "control_left" ) ) );			_controlLeft.x = 10;			_controlLeft.y = stage.stageHeight - 10 - _controlLeft.height;			addChild( _controlRight = new Image( StaticAssetManager.instance.getTexture( "control_right" ) ) );			_controlRight.x = _controlLeft.x + _controlLeft.width + 10;			_controlRight.y = _controlLeft.y;			addChild( _controlUp = new Image( StaticAssetManager.instance.getTexture( "control_up" ) ) );			_controlUp.x = stage.stageWidth - 10 - _controlUp.width;			_controlUp.y = _controlLeft.y;			addChild( _controlDown = new Image( StaticAssetManager.instance.getTexture( "control_down" ) ) );			_controlDown.x = _controlUp.x - _controlUp.width - 10;			_controlDown.y = _controlLeft.y;			switch( _worldID )			{				case 1:					this._snowModule = new SnowModule();					this.addChild( this._snowModule.getView() );					break;			}			// add gui			addChild( _gameGui = new GameGui( _levelID, _worldID ) );			_gameGui.addEventListener( GameGuiEvent.INGAME_RESTART_REQUEST, restartRequest );			_gameGui.addEventListener( GameGuiEvent.PAUSE_REQUEST, pauseRequest );			_gameGui.addEventListener( GameGuiEvent.RESUME_REQUEST, resumeRequest );			_gameGui.addEventListener( GameGuiEvent.GAME_END_REQUEST, gameEndRequest );			_gameGui.addEventListener( GameGuiEvent.NEXT_LEVEL_REQUEST, nextLevelRequest );			if( !CONFIG::IS_IOS_VERSION && !CONFIG::IS_ANDROID_VERSION )			{				stage.addEventListener( KeyboardEvent.KEY_DOWN, onKeydown );				stage.addEventListener( KeyboardEvent.KEY_UP, onKeyup );			}			addEventListener( TouchEvent.TOUCH, onTouch );			reset();		}		private function addLibraryElements():void		{			this._container.addChild( this._libraryElementContainer = new Sprite );			var length:int = this._levelData.libraryElements.length;			for( var i:int = 0; i < length; i++ )			{				var libraryElementVO:LibraryElementVO = this._levelData.libraryElements[ i ];				switch( libraryElementVO.className )				{					case CLibraryElement.CRATE_0:						var crate:BaseCrate = new SmallCrate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;					case CLibraryElement.CRATE_1:						crate = new Crate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;					case CLibraryElement.CRATE_2:						crate = new LongCrate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;					case CLibraryElement.CRATE_3:						crate = new SmallLongCrate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;					case CLibraryElement.CRATE_4:						crate = new RampCrate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;					case CLibraryElement.CRATE_5:						crate = new SmallRampCrate( this._world, libraryElementVO.position, libraryElementVO.scale );						this._libraryElementContainer.addChild( crate.image );						this._crates.push( crate );						break;				}			}		}		private function addBackground( textureName:String, baseYOffset:Number, easing:Point, xOverlap:Number, scale:Number ):void		{			var backgroundVO:BackgroundVO = new BackgroundVO;			backgroundVO.easing = easing;			_backgroundVOs.push( backgroundVO );			backgroundVO.container = new Sprite;			addChild( backgroundVO.container );			for( var i = 0; i < 5; i++ )			{				var backgroundPiece:MovieClip = new MovieClip( StaticAssetManager.instance.getTextures( textureName ) );				backgroundVO.container.addChild( backgroundPiece );				backgroundVO.elements.push( backgroundPiece );				backgroundPiece.scaleX = backgroundPiece.scaleY = scale;				backgroundPiece.currentFrame = i == 4 ? 0 : i;				backgroundPiece.x = i * ( backgroundPiece.width + xOverlap );				backgroundPiece.y = baseYOffset;			}		}		private function createBridges():void		{			for( var i:uint = 0; i < _levelData.bridgePoints.length; i += 2 )			{				createBridge( new Point( _levelData.bridgePoints[ i ].x, _levelData.bridgePoints[ i ].y ), new Point( _levelData.bridgePoints[ i + 1 ].x, _levelData.bridgePoints[ i + 1 ].y ) );			}		}		private function createBridge( $pointA:Point, $pointB:Point ):void		{			var bridgeAngle:Number = Math.atan2( $pointB.y - $pointA.y, $pointB.x - $pointA.x );			var bridgeElementWidth:uint = 30;			var bridgeElementHeight:uint = 15;			var bridgeDistance:Number = Point.distance(					new Point( $pointA.x, $pointA.y ),					new Point( $pointB.x, $pointB.y )			);			var pieces:Number = Math.floor( bridgeDistance / bridgeElementWidth ) + 1;			if( bridgeDistance % bridgeElementWidth == 0 )			{				pieces++;			}			_bridgeElements.push( new Vector.<BridgeElement> );			_bridgeB2Bodies.push( new Vector.<b2Body> );			for( var i:uint = 0; i < pieces; i++ )			{				var isLockedBridgeElement:Boolean = false;				if( i == 0 || i == pieces - 1 )				{					isLockedBridgeElement = true;				}				_bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ].push(						new Box(								_world,								"WALL",								$pointA.x + i * bridgeElementWidth * Math.cos( bridgeAngle ),								$pointA.y + i * bridgeElementWidth * Math.sin( bridgeAngle ),								bridgeElementWidth,								bridgeElementHeight,								!isLockedBridgeElement,								false,								1,								1,								0,								false,								CBox2D.BRIDGE_FILTER_CATEGORY,								CBox2D.BRIDGE_FILTER_MASK						).body				);				_bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ][ _bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ].length - 1 ].SetAngle( bridgeAngle );				_bridgeElements[ _bridgeElements.length - 1 ].push( _container.addChild( new BridgeElement ) );				if( i > 0 )				{					var tmpJoin:b2RevoluteJointDef = new b2RevoluteJointDef();					tmpJoin.Initialize(							_bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ][ i - 1 ],							_bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ][ i ],							_bridgeB2Bodies[ _bridgeB2Bodies.length - 1 ][ i - 1 ].GetWorldPoint(									new b2Vec2(											bridgeElementWidth / 30 / 2,											0									)							)					);					tmpJoin.localAnchorB = new b2Vec2(							-bridgeElementWidth / 30 / 2,							0					);					_b2Joints.push( _world.CreateJoint( tmpJoin ) );				}			}		}		protected function addCoinToWorld( x:Number, y:Number ):void		{			_coins.push( _coinContainer.addChild( new Coin ) );			_coins[ _coins.length - 1 ].x = x;			_coins[ _coins.length - 1 ].y = y;			_coins[ _coins.length - 1 ].touchable = false;		}		private function reset():void		{			// Reset init-variables			_isLost = false;			_isWon = false;			_canControll = true;			_left = false;			_right = false;			_up = false;			_down = false;			_isGameStarted = false;			_collectedCoin = 0;			_collectedExtraCoins = 0;			this._countOfFrontFlip = 0;			this._countOfBackFlip = 0;			this._countOfNiceAirTime = 0;			this._countOfNiceWheelie = 0;			// Clear last car			disposeCar();			// Create car			var carChildIndex:int = _container.getChildIndex( _terrainContainer );			var carData:CarData = CarDatas.getData( PlayerData.carID );			_car = new ExtendedCar( _world, _levelData.startPoint.x, _levelData.startPoint.y, carData );			_container.addChildAt( _wheelRight = new Image( StaticAssetManager.instance.getTexture( "wheel_" + carData.graphicID ) ), carChildIndex );			_wheelRight.touchable = false;			_wheelRight.pivotX = _wheelRight.pivotY = _wheelRight.width / 2;			_container.addChildAt( _wheelLeft = new Image( StaticAssetManager.instance.getTexture( "wheel_" + carData.graphicID ) ), carChildIndex );			_wheelLeft.touchable = false;			_wheelLeft.pivotX = _wheelLeft.pivotY = _wheelLeft.width / 2;			_container.addChildAt( _carBody = new Image( StaticAssetManager.instance.getTexture( "car_body_" + carData.graphicID ) ), carChildIndex );			_carBody.touchable = false;			_carBody.pivotX = _carBody.width / 2;			_carBody.pivotY = _carBody.height / 1.5;			switch( _worldID )			{				case 1:					_car.wheelLeft.SetLinearDamping( _car.damping + .3 );					_car.wheelRight.SetLinearDamping( _car.damping + .3 );					break;			}			// Reset camera			_lastCameraStepOffset.setTo( 0, 0 );			updateCamera( false );			this.resetCrates();			// Reset game object positions			for( var i:int = 0; i < _levelData.gameObjects.length; i++ )			{				_gameObjects[ _gameObjects.length - 1 ].x = _levelData.gameObjects[ i ].x;				_gameObjects[ _gameObjects.length - 1 ].y = _levelData.gameObjects[ i ].y;				_gameObjects[ _gameObjects.length - 1 ].rotation = _levelData.gameObjects[ i ].rotation;			}			// Reset small rocks			for( i = 0; i < _smallRocks.length; i++ )			{				Tweener.removeTweens( _smallRocks[ i ] );				_smallRocks[ i ].alpha = 0;				_smallRocks[ i ].visible = false;			}			// Reset coins			for( i = 0; i < _coins.length; i++ )			{				Tweener.removeTweens( _coins[ i ] );				_coins[ i ].reset();				_coins[ i ].x = _levelData.coinPoints[ i ].x;				_coins[ i ].y = _levelData.coinPoints[ i ].y;			}			// Start level			onUpdate( new Event( Event.ENTER_FRAME ) );			this._gameGui.showStartGamePanel( exit );			this._gameGui.enable();		}		private function resetCrates():void		{			var length:int = this._crates.length;			for( var i:int = 0; i < length; i++ )			{				this._crates[ i ].reset();			}		}		private function start():void		{			_isGameStarted = true;			_gameTime = 0;			_gameStartTime = new Date().time;			//CONFIG::IS_IOS_VERSION {			//}			//CONFIG::IS_ANDROID_VERSION {			//}			addEventListener( Event.ENTER_FRAME, onUpdate );			SoundHandler.play( "SND_GAME_BACK", {loops: 99999} );			//SoundHandler.play( "SND_CAR_BACK", { loops: 99999 } );		}		protected function createGroundPhysics( groundPoints:Vector.<Point> ):void		{			for( var i:int = 0; i < groundPoints.length - 1; i++ )			{				var angle:Number = Math.atan2( groundPoints[ i + 1 ].y - groundPoints[ i ].y, groundPoints[ i + 1 ].x - groundPoints[ i ].x );				var distance:Number = Math.sqrt(						Math.pow(								Math.abs( groundPoints[ i + 1 ].x - groundPoints[ i ].x ),								2 ) +						Math.pow(								Math.abs( groundPoints[ i + 1 ].y - groundPoints[ i ].y ), 2 ) )				_mapElements.push( createBox( "WALL", groundPoints[ i ].x, groundPoints[ i ].y, distance, 1, false, true, 1, 1, angle, false, CBox2D.GROUND_FILTER_CATEGORY, CBox2D.GROUND_FILTER_MASK ) );				_mapElements[ _mapElements.length - 1 ].SetPosition( new b2Vec2( ( groundPoints[ i ].x / CBox2D.PIXELS_TO_METRE + ( groundPoints[ i + 1 ].x - groundPoints[ i ].x ) / 2 / CBox2D.PIXELS_TO_METRE ), ( groundPoints[ i ].y / CBox2D.PIXELS_TO_METRE + ( groundPoints[ i + 1 ].y - groundPoints[ i ].y ) / 2 / CBox2D.PIXELS_TO_METRE ) ) );			}		}		private function createBox( $userData:Object, $px:Number, $py:Number, $width:Number, $height:Number, $isDynamic:Boolean, $isFixedRotation:Boolean, $friction:Number = .4, $density:Number = 1, $angle:Number = 0, $isKinematic:Boolean = false, $filterCategory = 0, $filterMask:uint = 0 ):b2Body		{			$px += $width / 2;			$py += $height / 2;			var my_body:b2BodyDef = new b2BodyDef();			my_body.position.Set( $px / CBox2D.PIXELS_TO_METRE, $py / CBox2D.PIXELS_TO_METRE );			if( $isDynamic )			{				my_body.type = b2Body.b2_dynamicBody;				my_body.fixedRotation = false;				my_body.angle = $angle;			}			else if( $isKinematic )			{				my_body.type = b2Body.b2_kinematicBody;				my_body.angle = $angle;			}			if( $isFixedRotation )			{				my_body.fixedRotation = true;				my_body.angle = $angle;			}			var my_box:b2PolygonShape = new b2PolygonShape();			my_box.SetAsBox( $width / 2 / CBox2D.PIXELS_TO_METRE, $height / 2 / CBox2D.PIXELS_TO_METRE );			var my_fixture:b2FixtureDef = new b2FixtureDef();			my_fixture.shape = my_box;			my_fixture.friction = $friction;			my_fixture.density = $density;			if( $filterCategory != 0 )			{				var filter:b2FilterData = new b2FilterData();				filter.categoryBits = $filterCategory;				filter.maskBits = $filterMask;				my_fixture.filter = filter;			}			var world_body:b2Body = _world.CreateBody( my_body );			world_body.SetUserData( $userData );			world_body.CreateFixture( my_fixture );			return world_body;		}		protected function calculateGameTime():void		{			if( _isGameStarted )			{				var now:Number = new Date().time;				_gameTime = Math.max( 0, now - _gameStartTime - _totalPausedTime );			}			else			{				_gameTime = 0;			}		}		protected function updateGameGui():void		{			_gameGui.updateCoinCount( _collectedCoin + _collectedExtraCoins );			_gameGui.updateTime( CGameTimeValues.MAXIMUM_GAME_TIME - _gameTime );		}		private function onUpdate( event:Event ):void		{			if( !isGameFinished )			{				calculateGameTime();				updateGameGui();			}			if( _isGameStarted && !isGameFinished && _gameTime >= CGameTimeValues.MAXIMUM_GAME_TIME )			{				addEffect( _carBody.x - 30, _carBody.y - 20, CGameEffect.TYPE_TIME_OUT );				lose();				return;			}			// update controll vectors			if( _canControll )			{				if( _left != _right && ( _left || _right ) )				{					if( _left )					{						_car.rotateLeft();					}					else					{						_car.rotateRight();					}				}				if( _up != _down && ( _up || _down ) )				{					if( _up )					{						_car.accelerateToRight();					}					else					{						_car.accelerateToLeft();					}				}			}			// box2d default stepps			_world.Step( CBox2D.BOX2D_TIMESTEP, CBox2D.BOX2D_VELOCITY_ITERATIONS, CBox2D.BOX2D_POSITION_ITERATIONS );			_world.ClearForces();			// update car elements positions			_carBody.x = _car.carBody.GetPosition().x * CBox2D.PIXELS_TO_METRE + _car.getGraphicXOffset();			_carBody.y = _car.carBody.GetPosition().y * CBox2D.PIXELS_TO_METRE + _car.getGraphicYOffset();			_carBody.rotation = _car.carBody.GetAngle();			_wheelRight.x = _car.wheelLeft.GetPosition().x * CBox2D.PIXELS_TO_METRE;			_wheelRight.y = _car.wheelLeft.GetPosition().y * CBox2D.PIXELS_TO_METRE;			_wheelRight.rotation = _car.wheelRight.GetAngle();			_wheelLeft.x = _car.wheelRight.GetPosition().x * CBox2D.PIXELS_TO_METRE;			_wheelLeft.y = _car.wheelRight.GetPosition().y * CBox2D.PIXELS_TO_METRE;			_wheelLeft.rotation = _car.wheelRight.GetAngle();			for( var i:int = 0; i < _bridgeElements.length; i++ )			{				for( var j:uint = 0; j < _bridgeElements[ i ].length; j++ )				{					_bridgeElements[ i ][ j ].x = _bridgeB2Bodies[ i ][ j ].GetPosition().x * CBox2D.PIXELS_TO_METRE;					_bridgeElements[ i ][ j ].y = _bridgeB2Bodies[ i ][ j ].GetPosition().y * CBox2D.PIXELS_TO_METRE;					_bridgeElements[ i ][ j ].rotation = _bridgeB2Bodies[ i ][ j ].GetAngle();				}			}			this.updateCrates();			this.updateCamera();			this.updateModules();			// update container position			var blockXMove:Boolean = false;			_container.x = -_camera.x;			_container.x = Math.min( _container.x, -10 );			_container.x = Math.max( _container.x, -_levelData.maxWidth + stage.stageWidth + 10 );			if( _isLost || _container.x == -10 || _container.x == -_levelData.maxWidth + stage.stageWidth + 10 )			{				blockXMove = true;			}			_container.y = -_camera.y;			_container.y = Math.max( _container.y, -_levelData.maxCameraY );			this.updateBackgrounds( blockXMove );			// check car properties			checkWheelieState();			if( carOnAir() )			{				if( !_car.isOnAir )				{					_car.onAirStartGameTime = _gameTime;					_car.isOnAir = true;					_car.jumpAngle = 0;					_car.lastAngleOnGround = Math.atan2( _wheelLeft.y - _wheelRight.y, _wheelLeft.x - _wheelRight.x );					_car.lastAngleOnGround = _wheelLeft.x - _wheelLeft.x < 0 ? ( Math.PI * 2 + _car.lastAngleOnGround ) : _car.lastAngleOnGround;					while( _car.lastAngleOnGround > Math.PI * 2 )					{						_car.lastAngleOnGround -= Math.PI * 2;					}				}				var currentAngle:Number = Math.atan2( _wheelLeft.y - _wheelRight.y, _wheelLeft.x - _wheelRight.x );				currentAngle = _wheelLeft.x - _wheelLeft.x < 0 ? ( Math.PI * 2 + currentAngle ) : currentAngle;				while( currentAngle > Math.PI * 2 )				{					currentAngle -= Math.PI * 2;				}				var angleDiff:Number = currentAngle - _car.lastAngleOnGround;				if( angleDiff < -Math.PI )				{					angleDiff += Math.PI * 2;					angleDiff *= -1;				}				else if( angleDiff > Math.PI )				{					angleDiff -= Math.PI * 2;					angleDiff *= -1;				}				_car.lastAngleOnGround = currentAngle;				_car.jumpAngle += angleDiff;			}			else if( _car.isOnAir )			{				_car.isOnAir = false;				_car.jumpAngle *= 180 / Math.PI;				if( _car.jumpAngle > 200 )				{					startFrontFlipRutin();				}				else if( _car.jumpAngle < -200 )				{					startBackFlipRutin();				}				if( _gameTime - _car.onAirStartGameTime > CGameTimeValues.MINIMUM_TIME_TO_NICE_AIR_IN_MS )				{					startNiceAirTimeRutin();				}			}			var leftAngularVelocity:Number = Math.abs( _car.wheelRight.GetAngularVelocity() );			var rightAngularVelocity:Number = Math.abs( _car.wheelLeft.GetAngularVelocity() );			if( !_car.rightWheelOnAir && ( _up || _down ) && _smallRocks.length > 0 && leftAngularVelocity > 5 && Math.random() > .7 )			{				_usedSmallRocks.push( _smallRocks[ _smallRocks.length - 1 ] );				_smallRocks.pop();				_usedSmallRocks[ _usedSmallRocks.length - 1 ].visible = true;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].alpha = 1;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].x = _wheelLeft.x + ( _up ? -1 : 1 ) * _wheelLeft.width / 4;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].y = _wheelLeft.y + _wheelLeft.height / 4;				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					time: .4,					rotation: Math.random() * ( Math.PI * 4 ),					x: _wheelLeft.x + Math.cos( Math.PI * 2 - _carBody.rotation ) * ( _up ? -1 : 1 ) * ( Math.random() * 20 + 10 )				} );				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					time: .2,					y: _wheelLeft.y + Math.sin( Math.PI * 2 - _carBody.rotation ) * ( Math.random() * 15 + 5 ) - 10				} );				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					delay: .2,					y: _wheelLeft.y + Math.sin( Math.PI * 2 - _carBody.rotation ) * ( Math.random() * 5 ),					time: .3,					alpha: 0,					transition: "linear",					onComplete: releaseSmallRock,					onCompleteParams: [ _usedSmallRocks[ _usedSmallRocks.length - 1 ] ]				} );			}			if( !_car.leftWheelOnAir && ( _up || _down ) && _smallRocks.length > 0 && rightAngularVelocity > 5 && Math.random() > .7 )			{				_usedSmallRocks.push( _smallRocks[ _smallRocks.length - 1 ] );				_smallRocks.pop();				_usedSmallRocks[ _usedSmallRocks.length - 1 ].visible = true;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].alpha = 1;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].x = _wheelRight.x + ( _up ? -1 : 1 ) * _wheelLeft.width / 4;				_usedSmallRocks[ _usedSmallRocks.length - 1 ].y = _wheelRight.y + _wheelRight.height / 4;				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					time: .4,					rotation: Math.random() * ( Math.PI * 4 ),					x: _wheelRight.x + Math.cos( Math.PI * 2 - _carBody.rotation ) * ( _up ? -1 : 1 ) * ( Math.random() * 20 + 10 )				} );				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					time: .2,					y: _wheelRight.y + Math.sin( Math.PI * 2 - _carBody.rotation ) * ( Math.random() * 15 + 5 ) - 10				} );				Tweener.addTween( _usedSmallRocks[ _usedSmallRocks.length - 1 ], {					delay: .2,					y: _wheelRight.y + Math.sin( Math.PI * 2 - _carBody.rotation ) * ( Math.random() * 5 ),					time: .3,					alpha: 0,					transition: "linear",					onComplete: releaseSmallRock,					onCompleteParams: [ _usedSmallRocks[ _usedSmallRocks.length - 1 ] ]				} );			}			checkContactList( _car.hitArea.GetContactList() );			checkCoinPickUp();			checkWin();		}		private function checkWheelieState():void		{			var isWheelieInProgress:Boolean = ( _car.rightWheelOnAir && !_car.leftWheelOnAir ) || ( !_car.rightWheelOnAir && _car.leftWheelOnAir );			if( !isWheelieInProgress && _car.isOnWheelie && _gameTime - _car.onWheelieStartGameTime > CGameTimeValues.MINIMUM_TIME_TO_NICE_WHEELIE_IN_MS )			{				startNiceWheelieTimeRutin();			}			if( isWheelieInProgress && !_car.isOnWheelie )			{				_car.onWheelieStartGameTime = _gameTime;			}			_car.isOnWheelie = isWheelieInProgress;		}		private function updateCrates():void		{			var length:int = this._crates.length;			for( var i:int = 0; i < length; i++ )			{				this._crates[ i ].image.x = this._crates[ i ].body.GetPosition().x * CBox2D.PIXELS_TO_METRE;				this._crates[ i ].image.y = this._crates[ i ].body.GetPosition().y * CBox2D.PIXELS_TO_METRE;				this._crates[ i ].image.rotation = this._crates[ i ].body.GetAngle();			}		}		private function updateCamera( useCameraEase:Boolean = true ):void		{			if( _isLost )			{				return;			}			_lastCameraStepOffset.setTo(					( ( _car.carBody.GetPosition().x * CBox2D.PIXELS_TO_METRE + _cameraOffset.x ) - _camera.x ) / ( useCameraEase ? CAMERA_EASE.x : 1 ),					( ( _car.carBody.GetPosition().y * CBox2D.PIXELS_TO_METRE + _cameraOffset.y ) - _camera.y ) / ( useCameraEase ? CAMERA_EASE.y : 1 )			);			_camera.x += _lastCameraStepOffset.x;			_camera.y += _lastCameraStepOffset.y;		}		private function updateModules():void		{			switch( _worldID )			{				case 1:					_snowModule.update();					break;			}		}		private function updateBackgrounds( blockXMove:Boolean ):void		{			for( var i:int = 0; i < _backgroundVOs.length; i++ )			{				var backgroundVO:BackgroundVO = _backgroundVOs[ i ];				if( !blockXMove )				{					backgroundVO.container.x -= _lastCameraStepOffset.x * backgroundVO.easing.x;					while( backgroundVO.container.x > 0 )					{						for( var j:uint = 0; j < backgroundVO.elements.length; j++ )						{							backgroundVO.elements[ j ].currentFrame = backgroundVO.elements[ j ].currentFrame == 0 ? backgroundVO.elements[ j ].numFrames - 1 : backgroundVO.elements[ j ].currentFrame - 1;						}						backgroundVO.container.x -= backgroundVO.elements[ 0 ].width;					}					while( backgroundVO.container.x < -backgroundVO.elements[ 0 ].width )					{						for( j = 0; j < backgroundVO.elements.length; j++ )						{							backgroundVO.elements[ j ].currentFrame = backgroundVO.elements[ j ].currentFrame == backgroundVO.elements[ j ].numFrames - 1 ? 0 : backgroundVO.elements[ j ].currentFrame + 1;						}						backgroundVO.container.x += backgroundVO.elements[ 0 ].width;					}				}				backgroundVO.container.y = stage.stageHeight - backgroundVO.container.height + _container.y * backgroundVO.easing.y;			}		}		private function checkCoinPickUp():void		{			var length:int = this._coins.length;			for( var i:int = 0; i < length; i++ )			{				var coin:Coin = _coins[ i ];				if( !coin.isCollected && Math.sqrt( Math.pow( this._carBody.x - coin.x, 2 ) + Math.pow( this._carBody.y - coin.y, 2 ) ) < 30 )				{					coin.collect();					this._collectedCoin++;					this.checkCoinTasks();				}			}		}		private function checkWin():void		{			if( !_isWon && _carBody.x >= _levelData.finishPoint.x )			{				win();			}		}		private function releaseSmallRock( $target:Image ):void		{			$target.visible = false;			_smallRocks.push( $target );			for( var i:uint = 0; i < _usedSmallRocks.length; i++ )			{				if( _usedSmallRocks[ i ] == $target )				{					_usedSmallRocks.splice( i, 1 );					break;				}			}		}		private function checkContactList( $contactList:b2ContactEdge = null ):void		{			if( $contactList )			{				var finished:Boolean = false				while( $contactList && !finished )				{					var fixture:b2Contact = $contactList.contact;					if( fixture.GetFixtureB().GetBody().GetUserData() == "WALL" && fixture.IsTouching() )					{						finished = true;					}					else					{						$contactList = $contactList.next;					}				}				if( !_isLost && !_isWon && finished )				{					addEffect( _carBody.x - 30, _carBody.y - 20, CGameEffect.TYPE_CRUSHED );					lose();				}			}		}		private function carOnAir():Boolean		{			var contactList:b2ContactEdge = _car.wheelLeft.GetContactList();			_car.leftWheelOnAir = true;			while( contactList && _car.leftWheelOnAir )			{				var fixture:b2Contact = contactList.contact;				if( fixture.GetFixtureA().GetBody().GetUserData() == "WALL" && fixture.IsTouching() )				{					_car.leftWheelOnAir = false;				}				else				{					contactList = contactList.next;				}			}			contactList = _car.wheelRight.GetContactList();			_car.rightWheelOnAir = true;			while( contactList && _car.rightWheelOnAir )			{				fixture = contactList.contact;				if( fixture.GetFixtureA().GetBody().GetUserData() == "WALL" && fixture.IsTouching() )				{					_car.rightWheelOnAir = false;				}				else				{					contactList = contactList.next;				}			}			if( !_car.leftWheelOnAir || !_car.rightWheelOnAir )			{				return false;			}			else			{				return true;			}		}		protected function startFrontFlipRutin():void		{			this._countOfFrontFlip++;			this._collectedExtraCoins += CScore.SCORE_FRONT_FLIP;			this.checkFrontFlipTasks();			this._gameGui.addNotification( CNotification.FRONT_FLIP );		}		protected function startBackFlipRutin():void		{			this._countOfBackFlip++;			this._collectedExtraCoins += CScore.SCORE_BACK_FLIP;			this.checkBackFlipTasks();			this._gameGui.addNotification( CNotification.BACK_FLIP );		}		protected function startNiceAirTimeRutin():void		{			this._countOfNiceAirTime++;			this._collectedExtraCoins += CScore.SCORE_NICE_AIR_TIME;			this.checkNiceAirTimeTasks();			this._gameGui.addNotification( CNotification.NICE_AIR );		}		protected function startNiceWheelieTimeRutin():void		{			this._countOfNiceWheelie++;			this._collectedExtraCoins += CScore.SCORE_NICE_WHEELIE_TIME;			this.checkNiceWheelieTimeTasks();			this._gameGui.addNotification( CNotification.NICE_WHEELIE );		}		protected function addEffect( x:Number, y:Number, effectType:String ):void		{			var effect:Image = new Image( StaticAssetManager.instance.getTexture( effectType ) );			effect.pivotX = effect.width / 2;			effect.pivotY = effect.height / 2;			effect.x = x;			effect.y = y;			effect.scaleX = effect.scaleY = .5;			effect.alpha = 0;			Tweener.addTween( effect, {time: .5, alpha: 1, scaleX: 1, scaleY: 1} );			Tweener.addTween( effect, {				delay: 1.5,				time: .3,				alpha: 0,				scaleX: .5,				scaleY: .5,				onComplete: disposeEffect,				onCompleteParams: [ effect ]			} );			_container.addChild( effect );			_effects.push( effect );		}		protected function disposeEffect( effect:Image ):void		{			var length:int = _effects.length;			for( var i:int = 0; i < length; i++ )			{				if( _effects[ i ] == effect )				{					_effects.splice( i, 1 );					return;				}			}			effect.removeFromParent( true );			effect = null;		}		private function onTouch( e:TouchEvent ):void		{			if( !_canControll )			{				return;			}			var touches:Vector.<Touch> = e.touches;			var tTouch:Touch;			var length:uint = touches.length;			for( var i:uint = 0; i < touches.length; i++ )			{				tTouch = touches[ i ];				if( tTouch.target == _controlLeft )				{					_left = tTouch.phase == TouchPhase.BEGAN ? true : tTouch.phase == TouchPhase.ENDED ? false : _left;				}				else if( tTouch.target == _controlRight )				{					_right = tTouch.phase == TouchPhase.BEGAN ? true : tTouch.phase == TouchPhase.ENDED ? false : _right;				}				else if( tTouch.target == _controlUp )				{					_up = tTouch.phase == TouchPhase.BEGAN ? true : tTouch.phase == TouchPhase.ENDED ? false : _up;				}				else if( tTouch.target == _controlDown )				{					_down = tTouch.phase == TouchPhase.BEGAN ? true : tTouch.phase == TouchPhase.ENDED ? false : _down;				}			}		}		private function onKeydown( event:KeyboardEvent ):void		{			switch( event.keyCode )			{				case Keyboard.LEFT:					_left = true;					break;				case Keyboard.RIGHT:					_right = true;					break;				case Keyboard.UP:					_up = true;					break;				case Keyboard.DOWN:					_down = true;					break			}		}		private function onKeyup( event:KeyboardEvent ):void		{			switch( event.keyCode )			{				case Keyboard.LEFT:					_left = false;					break;				case Keyboard.RIGHT:					_right = false;					break;				case Keyboard.UP:					_up = false;					break;				case Keyboard.DOWN:					_down = false;					break;			}		}		private function lose():void		{			SoundHandler.stopAll();			SoundHandler.play( 'SND_FAIL' );			_isLost = true;			_canControll = false;			this._gameGui.disable();			this.resetKeys();			// Game over request			Tweener.addTween( this, {time: 2, onComplete: restartRequest} );		}		private function resetKeys():void		{			this._left = false;			this._right = false;			this._up = false;			this._down = false;		}		private function win():void		{			SoundHandler.stopAll();			SoundHandler.play( 'SND_WIN' );			_isWon = true;			_canControll = false;			this._gameGui.disable();			addEffect( _carBody.x - 30, _carBody.y - 20, CGameEffect.TYPE_LEVEL_COMPLETED );			// Reset angular velocity			_car.wheelLeft.SetAngularVelocity( 0 );			_car.wheelRight.SetAngularVelocity( 0 );			// Reset keys			_left = false;			_right = false;			_up = false;			_down = false;			// Game over request			Tweener.addTween( this, {time: 2, onComplete: gameEndRequest} );		}		private function restartRequest( event:GameGuiEvent = null ):void		{			if( event == null )			{				event = new GameGuiEvent( GameGuiEvent.INGAME_RESTART_REQUEST )			}			dispatchEvent( event );		}		private function pauseRequest( event:GameGuiEvent = null ):void		{			disposeStartCounter();			_pauseStartTime = new Date().time;			removeEventListener( Event.ENTER_FRAME, onUpdate );		}		private function resumeRequest( event:GameGuiEvent = null ):void		{			if( !_isGameStarted )			{				start();				pauseRequest();				_gameGui.disposeStartGamePanel();			}			startResumeCounter();		}		private function startResumeCounter():void		{			addChild( _startCounter = new StartCounter( resume, disposeStartCounter ) );		}		private function disposeStartCounter():void		{			if( _startCounter )			{				_startCounter.removeFromParent( true );				_startCounter = null;			}		}		private function resume():void		{			_totalPausedTime += new Date().time - _pauseStartTime;			addEventListener( Event.ENTER_FRAME, onUpdate );		}		private function gameEndRequest( e:GameGuiEvent = null ):void		{			var levelEndVO:LevelEndVO = new LevelEndVO(					this._collectedCoin + _collectedExtraCoins,					this._gameTime,					this._isWon,					this._levelID,					this._worldID			);			this.checkGameOverTasks( levelEndVO );			this._gameGui.showGameOverPanel( levelEndVO, exit );		}		private function nextLevelRequest( e:GameGuiEvent = null ):void		{			dispatchEvent( new MenuEvent( MenuEvent.NEXT_LEVEL_REQUEST, {levelID: _levelID, worldID: _worldID} ) );		}		private function exit( e:GameGuiEvent ):void		{			dispatchEvent( new GameGuiEvent( GameGuiEvent.LEVEL_SELECT_REQUEST, _worldID ) );		}		public function restartRutin():void		{			removeEventListener( Event.ENTER_FRAME, onUpdate );			reset();		}		private function checkBackFlipTasks():void		{			this.checkBackAndFrontFlipTasks();			this.checkAllBonusCountsTasks();			switch( this._worldID )			{				case 0:					this._achievementManager.increaseAchievementCurrentValue( 0 );					if( this._countOfBackFlip == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 5 );					}					this._achievementManager.increaseAchievementCurrentValue( 15 );					break;				case 1:					this._achievementManager.increaseAchievementCurrentValue( 0 );					if( this._countOfBackFlip == 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 16 );					}					this._achievementManager.increaseAchievementCurrentValue( 18 );					break;				case 2:					if( this._countOfBackFlip == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 3 );					}					this._achievementManager.increaseAchievementCurrentValue( 9 );					if( this._countOfBackFlip == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 19 );					}					break;			}		}		private function checkFrontFlipTasks():void		{			this.checkBackAndFrontFlipTasks();			this.checkAllBonusCountsTasks();			switch( this._worldID )			{				case 0:					this._achievementManager.increaseAchievementCurrentValue( 1 );					break;				case 1:					if( this._countOfFrontFlip == 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 2 );					}					this._achievementManager.increaseAchievementCurrentValue( 7 );					break;				case 2:					this._achievementManager.increaseAchievementCurrentValue( 0 );					if( this._countOfFrontFlip == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 1 );					}					this._achievementManager.increaseAchievementCurrentValue( 15 );					break;			}		}		private function checkBackAndFrontFlipTasks():void		{			switch( this._worldID )			{				case 0:					if( this._countOfBackFlip >= 2 && this._countOfFrontFlip >= 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 11 );					}					break;				case 1:					if( this._countOfBackFlip >= 2 && this._countOfFrontFlip >= 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 12 );					}					break;				case 2:					if( this._countOfBackFlip >= 2 && this._countOfFrontFlip >= 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 10 );					}					break;			}		}		private function checkAllBonusCountsTasks():void		{			switch( this._worldID )			{				case 0:					if( this._countOfBackFlip >= 1 && this._countOfFrontFlip >= 1 && this._countOfNiceAirTime >= 1 && this._countOfNiceWheelie >= 1 )					{						this._achievementManager.increaseAchievementCurrentValue( 18 );					}					break;				case 1:					if( this._countOfBackFlip >= 1 && this._countOfFrontFlip >= 1 && this._countOfNiceAirTime >= 1 && this._countOfNiceWheelie >= 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 19 );					}					break;				case 2:					if( this._countOfBackFlip >= 2 && this._countOfFrontFlip >= 2 && this._countOfNiceAirTime >= 2 && this._countOfNiceWheelie >= 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 16 );					}					break;			}		}		private function checkNiceAirTimeTasks():void		{			this.checkAllBonusCountsTasks();			switch( this._worldID )			{				case 0:					this._achievementManager.increaseAchievementCurrentValue( 7 );					this._achievementManager.increaseAchievementCurrentValue( 13 );					break;				case 1:					this._achievementManager.increaseAchievementCurrentValue( 3 );					this._achievementManager.increaseAchievementCurrentValue( 9 );					if( this._countOfNiceAirTime == 2 )					{						this._achievementManager.increaseAchievementCurrentValue( 11 );					}					break;				case 2:					this._achievementManager.increaseAchievementCurrentValue( 8 );					break;			}		}		private function checkNiceWheelieTimeTasks():void		{			this.checkAllBonusCountsTasks();			switch( this._worldID )			{				case 0:					this._achievementManager.increaseAchievementCurrentValue( 9 );					if( this._countOfNiceWheelie == 5 )					{						this._achievementManager.increaseAchievementCurrentValue( 16 );					}					break;				case 1:					if( this._countOfNiceWheelie == 5 )					{						this._achievementManager.increaseAchievementCurrentValue( 5 );					}					this._achievementManager.increaseAchievementCurrentValue( 15 );					break;				case 2:					this._achievementManager.increaseAchievementCurrentValue( 5 );					if( this._countOfNiceWheelie == 7 )					{						this._achievementManager.increaseAchievementCurrentValue( 7 );					}					this._achievementManager.increaseAchievementCurrentValue( 14 );					break;			}		}		private function checkCoinTasks():void		{			switch( this._worldID )			{				case 0:					this._achievementManager.increaseAchievementCurrentValue( 2 );					this._achievementManager.increaseAchievementCurrentValue( 6 );					break;				case 1:					this._achievementManager.increaseAchievementCurrentValue( 6 );					this._achievementManager.increaseAchievementCurrentValue( 13 );					break;				case 2:					this._achievementManager.increaseAchievementCurrentValue( 4 );					this._achievementManager.increaseAchievementCurrentValue( 17 );					break;			}		}		private function checkGameOverTasks( levelEndVO:LevelEndVO ):void		{			switch( this._worldID )			{				case 0:					if( levelEndVO.starCount == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 3 );					}					if( _levelID == 0 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 10 );					}					if( _levelID == 11 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 14 );					}					if( this._collectedCoin == this._levelData.coinPoints.length )					{						this._achievementManager.increaseAchievementCurrentValue( 12 );					}					if( _levelID == 23 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 19 );					}					break;				case 1:					if( levelEndVO.starCount == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 1 );					}					if( this._collectedCoin == this._levelData.coinPoints.length )					{						this._achievementManager.increaseAchievementCurrentValue( 4 );					}					if( _levelID == 0 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 10 );					}					if( _levelID == 11 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 14 );					}					break;				case 2:					if( levelEndVO.starCount == 3 )					{						this._achievementManager.increaseAchievementCurrentValue( 2 );					}					if( _levelID == 11 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 11 );					}					if( this._collectedCoin == this._levelData.coinPoints.length )					{						this._achievementManager.increaseAchievementCurrentValue( 12 );					}					if( _levelID == 23 && levelEndVO.isWon && levelEndVO.gameTime < 1000 * 25 )					{						this._achievementManager.increaseAchievementCurrentValue( 18 );					}					break;			}		}		private function disposeCoins():void		{			while( this._coins.length > 0 )			{				this._coins[ 0 ].removeFromParent( true );				this._coins[ 0 ] = null;				this._coins.shift();			}			this._coins = null;			this._coinContainer.removeFromParent( true );			this._coinContainer = null;		}		private function disposeCar():void		{			if( _car )			{				_car.dispose();				_car = null;				_carBody.removeFromParent( true );				_carBody = null;				_wheelRight.removeFromParent( true );				_wheelRight = null;				_wheelLeft.removeFromParent( true );				_wheelLeft = null;			}		}		private function disposeGui():void		{			this._gameGui.removeEventListener( GameGuiEvent.INGAME_RESTART_REQUEST, this.restartRequest );			this._gameGui.removeEventListener( GameGuiEvent.PAUSE_REQUEST, this.pauseRequest );			this._gameGui.removeEventListener( GameGuiEvent.RESUME_REQUEST, this.resumeRequest );			this._gameGui.removeEventListener( GameGuiEvent.GAME_END_REQUEST, this.gameEndRequest );			this._gameGui.removeEventListener( GameGuiEvent.NEXT_LEVEL_REQUEST, this.nextLevelRequest );			this._gameGui.removeFromParent( true );			this._gameGui = null;		}		private function disposeBackgrounds():void		{			for( var i:int = 0; i < _backgroundVOs.length; i++ )			{				for( var j:int = 0; j < _backgroundVOs[ i ].elements.length; j++ )				{					_backgroundVOs[ i ].elements[ j ].removeFromParent( true );					_backgroundVOs[ i ].elements[ j ] = null;				}				_backgroundVOs[ i ].elements.length = 0;				_backgroundVOs[ i ].elements = null;				_backgroundVOs[ i ].container.removeFromParent( true );				_backgroundVOs[ i ].container = null;			}			_backgroundVOs.length = 0;			_backgroundVOs = null;		}		private function disposeLibraryElements():void		{			this.disposeCrates();		}		private function disposeCrates():void		{			var length:int = this._crates.length;			for( var i:int = 0; i < length; i++ )			{				this._crates[ i ].dispose();				this._crates[ i ] = null;			}			this._crates.length = 0;			this._crates = null;		}		private function get isGameFinished():Boolean		{			return ( _isLost || _isWon ) && _gameStartTime;		}		override public function dispose():void		{			//CONFIG::IS_IOS_VERSION {			//}			//CONFIG::IS_ANDROID_VERSION {			//}			SoundHandler.stop( "SND_GAME_BACK" );			//SoundHandler.stop( "SND_CAR_BACK" );			Tweener.removeTweens( this );			// Remove listeners			this.removeEventListener( TouchEvent.TOUCH, this.onTouch );			this.removeEventListener( Event.ENTER_FRAME, this.onUpdate );			CONFIG::IS_FLASH_VERSION {				if( stage )				{					this.stage.removeEventListener( KeyboardEvent.KEY_DOWN, this.onKeydown );					this.stage.removeEventListener( KeyboardEvent.KEY_UP, this.onKeyup );				}			}			this.disposeBackgrounds();			this.disposeStartCounter();			this.disposeLibraryElements();			// Remove game images			while( _smallRocks.length > 0 )			{				_smallRocks[ 0 ].removeFromParent( true );				_smallRocks[ 0 ] = null;				_smallRocks.shift();			}			_smallRocks = null;			while( _usedSmallRocks.length > 0 )			{				Tweener.removeTweens( _usedSmallRocks[ 0 ] );				_usedSmallRocks[ 0 ].removeFromParent( true );				_usedSmallRocks[ 0 ] = null;				_usedSmallRocks.shift();			}			_usedSmallRocks = null;			while( _gameObjects.length > 0 )			{				_gameObjects[ 0 ].removeFromParent( true );				_gameObjects[ 0 ] = null;				_gameObjects.shift();			}			_gameObjects = null;			while( _terrains.length > 0 )			{				_terrains[ 0 ].texture.dispose();				_terrains[ 0 ].removeFromParent( true );				_terrains[ 0 ] = null;				_terrains.shift();			}			_terrains = null;			while( _effects.length > 0 )			{				Tweener.removeTweens( _effects[ 0 ] );				_effects[ 0 ].removeFromParent( true );				_effects[ 0 ] = null;				_effects.shift();			}			_effects = null;			for( var i:int = 0; i < _bridgeElements.length; i++ )			{				for( var j:uint = 0; j < _bridgeElements[ i ].length; j++ )				{					_bridgeElements[ i ][ j ].removeFromParent( true );					_bridgeElements[ i ][ j ] = null;				}				_bridgeElements[ i ].length = 0;			}			_bridgeElements.length = 0;			_bridgeElements = null;			for( i = 0; i < _bridgeB2Bodies.length; i++ )			{				for( j = 0; j < _bridgeB2Bodies[ i ].length; j++ )				{					_world.DestroyBody( _bridgeB2Bodies[ i ][ j ] );					_bridgeB2Bodies[ i ][ j ] = null;				}				_bridgeB2Bodies[ i ].length = 0;			}			_bridgeB2Bodies.length = 0;			_bridgeB2Bodies = null;			if( _snowModule )			{				_snowModule.dispose();				_snowModule = null;			}			this.disposeCoins();			this.disposeCar();			this.disposeGui();			this._container.removeFromParent( true );			this._container = null;			// Remove control buttons			this._controlLeft.removeFromParent( true );			this._controlLeft = null;			this._controlRight.removeFromParent( true );			this._controlRight = null;			// Clear Starling			Starling.juggler.purge();			super.dispose();		}	}}