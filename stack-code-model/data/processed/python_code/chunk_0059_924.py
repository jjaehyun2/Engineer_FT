package com.mcleodgaming.elevator.core{	import com.mcleodgaming.elevator.Main;	import com.mcleodgaming.elevator.events.*;	import com.mcleodgaming.elevator.util.*;	public class Elevator	{		//Elevator class represents a single elevator		public var name:String; //Name of elevator (e.g. "Elevator 1")		public var state:int; //Current ElevatorState		public var targetFloors:Array; //Array of target queued floors		public var targetFloorsMemory:Array; //Potentially record floors headed towards that request the opposite direction (not currently used)		public var floors:Array; //Available floors		public var currentFloor:Floor; //Current floor reference		public var entranceFloor:Floor; //Entrance floor reference		public var people:Array; //List of people inside the elvator		public var speedTimer:FrameTimer; //Amount of time it takes the elevator to reach a floor		public var waitTimer:FrameTimer; //Amount of time an elevator leaves its door open for people to board		public var capacity:int; //Maximum amount of occupants that can be held in the elevator		public function Elevator(params:Object):void {			//Get settings and set defaults			params = params || {};			name = params.name || "[NoName]";			capacity = (params.capacity) ? params.capacity : 10;			state = params.state || ElevatorState.IDLE;			floors = params.floors || new Array();			targetFloors = params.targetFloors || new Array();			currentFloor = (floors.length > 0) ? params.currentFloor || floors[0] : null;			entranceFloor = (floors.length > 0) ? params.entranceFloor || floors[0] : null;			speedTimer = new FrameTimer(params.speedTimer || 30);			waitTimer = new FrameTimer(params.waitTimer || 60);			people = new Array();			targetFloorsMemory = new Array();		}		public function tick():void {			//Function to perform each game tick			var index;			if(state == ElevatorState.IDLE) {				//Idling on the entrance floor			} else if(state == ElevatorState.RISING || state == ElevatorState.FALLING) {				//Elevator is currently rising or falling				speedTimer.tick();				//If the movement timer reaches 0				if(speedTimer.IsComplete) {					//Reset timer and validate the next floor					speedTimer.reset();					if(nextFloor()) {						//Verify direction state						if((nextFloor().index > currentFloor.index && state == ElevatorState.FALLING) || (nextFloor().index < currentFloor.index && state == ElevatorState.RISING)) {							state =  (nextFloor().index > currentFloor.index) ? ElevatorState.RISING : ElevatorState.FALLING;							Debug.warn("WARNING: HAD TO FORCE FLIP DIRECTION STATE", this);						}					}					//Proceed towards the next floor					var increase = (state == ElevatorState.RISING) ? 1 : -1;					//Verify floor destination exists					if(currentFloor.index + increase >= floors.length || currentFloor.index + increase < 0) {						Debug.warn("Problem with elevator: ", this);						//throw new Error("sorta almost went outta bounds", this);					}					//Get next floor index and force in bounds to prevent errors					index = targetFloors.indexOf(nextFloor());					currentFloor = floors[Math.max(0, Math.min(currentFloor.index + increase, floors.length-1))];					//Check to see if this is a target floor					if(targetFloors[index] == currentFloor) {						waitTimer.reset();						//Remove this floor from the targets list						targetFloors.splice(index, 1);						//Open doors						state = ElevatorState.WAITING;						//Get 1 pass in early						processFloor();						//Trigger ARRIVE event						EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.ARRIVE, { elevator: this, floor: currentFloor  }));					}				}			} else if(state == ElevatorState.RETURNING) {				//Elevator is returning towards the entrance				speedTimer.tick();				//If the movement timer reaches 0				if(speedTimer.IsComplete) {					speedTimer.reset();					//Get direction towards entrance floor					var dir = (currentFloor < entranceFloor) ? 1 : -1;					//Verify floor destination exists					if(currentFloor.index + dir >= floors.length || currentFloor.index + dir < 0) {						Debug.warn("Problem with elevator: ", this);						//throw new Error("sorta almost went outta bounds", this);					}					//Go to the next consecutive floor					currentFloor = floors[Math.max(0, Math.min(currentFloor.index + dir, floors.length-1))];					if(currentFloor == entranceFloor)						state = ElevatorState.IDLE; //Idle at entrance					waitTimer.reset();				}			} else if(state == ElevatorState.WAITING) {				//Elevator is waiting on a floor for passengers, processes the people that want to board each frame				processFloor();				waitTimer.tick();				if(waitTimer.IsComplete) {					//Done waiting					waitTimer.reset();					speedTimer.reset();					if(targetFloors.length <= 0) {						//TODO: Figure out if this is needed (relates to people "pressing buttons" while inside of the elevator)						//dumpFloorMemory();					}					if(!nextFloor()) {						//There are no people in the elevator, back to entrance						if(people.length > 0) {							//TODO: Consider moving/removing this check							throw new Error("People were left on the elevator while it prepared to go back to the entrance :< ", this)						}						if(currentFloor == entranceFloor) {							state = ElevatorState.IDLE; //At the entrance (TODO: Figure out when can this occur?)						} else {							//Dispatch the RELEASE event							EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.RELEASE, { elevator: this }));							//Head towards the entrance floor							state = ElevatorState.RETURNING; //Go towards the entrance							//Dispatch the DEPART event							EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.DEPART, { elevator: this, floor: currentFloor }));						}					} else {						//Decide what to do if we have a floor in our queue						//TODO: Consider removing people length check, the elevator shouldn't be able to know this information						//TODO: Consider removing this if statement altogehter, it may be impossible to enter						if(currentFloor == entranceFloor && people.length <= 0 && targetFloors.length <= 0) {							//No one got on the elevator at the entrance floor, begin idling							state = ElevatorState.IDLE;							EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.NOPASSENGERS, { elevator: this, floor: currentFloor }));						} else {							//Move towards the next room							state = (nextFloor().index > currentFloor.index) ? ElevatorState.RISING : ElevatorState.FALLING;							EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.DEPART, { elevator: this, floor: currentFloor }));						}					}				}			}		}		public function dumpFloorMemory():void {			//Grab floors from memory if there are any			while(targetFloorsMemory.length > 0) {				//if(targetFloors.length == 0)					queueFloor(targetFloorsMemory.splice(0, 1)[0]); //Just add the floor				//else if((isRising() && targetFloorsMemory[index].index > 0) || (isFalling() && targetFloorsMemory[index]))					//queueFloor(targetFloorsMemory.splice(index--, 1)[0]); //Floor is in the same direction we're going already, we can add it			}		}		public function nextFloor():Floor {			//TODO: Code this to not need the people.length? (use a special targetFloor array or toggle?)			if(targetFloors.length <= 0)				return null; //No target floors			if(isRising())				return (people.length > 0) ? targetFloors[0] : targetFloors[targetFloors.length - 1]; //With people inside next floor is the lowest, otherwise highest			else if(isFalling())				return (people.length > 0) ? targetFloors[targetFloors.length - 1] : targetFloors[0]; //With people inside next floor is the highest, otherwise lowest			else				return null; //No next floor		}		public function isHeadingTowards(floor:Floor, upwards:Boolean):Boolean {			//Determines if the elevator is headed towards a specific floor in the same queued direction (up or down)			if(upwards)				return (floor && isRising() && floor.index > currentFloor.index);			else				return (floor && isFalling() && floor.index < currentFloor.index);		}		public function isFree():Boolean {			//Determine if the elevator is in a state to move immediately			return (state == ElevatorState.IDLE || state == ElevatorState.RETURNING);		}		public function addPerson(person:Person):void {			//Add a person into the elevator and have them queue their floor			if(people.indexOf(person) < 0) {				people.push(person);				queueFloor(person.targetFloor);			}		}		public function removePerson(person:Person):void {			//Remove a person from the elevator			var index = people.indexOf(person);			if(index >= 0)				people.splice(index, 1);		}		public function queueFloor(floor:Floor):void {			//Attempt to queue a floor			if(!floor || targetFloors.indexOf(floor) >= 0)				return; //Cancel if already queued this floor or the floor provided is null			var self = this;			//Function to enqueue a floor via simple insertion sort			var enqueue = function() {				if(self.targetFloors.length <= 0) {					//No targetted floors, free to queue					self.targetFloors.push(floor);					if(self.people.length <= 0) {						//Trigger RESPOND event that a person's button press has been acknowledged						EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.RESPOND, { elevator: self, floor: floor }));					}				} else {					//Adds a floor in ascending order					for(var i = 0; i < self.targetFloors.length; i++) {						if(self.targetFloors[i] == floor) {							break; //Already queued this floor						} else if(i < self.targetFloors.length && self.targetFloors[i].index > floor.index) {							self.targetFloors.splice(i, 0, floor); 							break; //Insert at this index						} else if(i + 1 >= self.targetFloors.length){							self.targetFloors.push(floor);							break; //Insert at the end of the array						}					}				}			};			if(isRising()) {				//If rising, only queue if the pressed floor is in our direction				if(floor.index > currentFloor.index)					enqueue();				else {					if(targetFloorsMemory.indexOf(floor) < 0)						targetFloorsMemory.push(floor); //Someone inside the elevator pressed a floor in the opposite direction				}			} else if (isFalling()) {				//If falling, only queue if the pressed floor is in our direction				if(floor.index < currentFloor.index)					enqueue();				else {					if(targetFloorsMemory.indexOf(floor) < 0)						targetFloorsMemory.push(floor); //Someone inside the elevator pressed a floor in the opposite direction				}			} else if(isIdling()) {				if(currentFloor == floor) {					//Already on the floor so we can just enter waiting state					state = ElevatorState.WAITING;				} else {					//We're not already on the floor so enqueue it					enqueue();					if(isFree()) {						//We're free so we can go immediately						state = (floor.index > currentFloor.index) ? ElevatorState.RISING : ElevatorState.FALLING;						EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.DEPART, { elevator: this, floor: currentFloor }));					}				}			}		}		public function hasQueued(floor:Floor):Boolean {			//Determine if a floor has been queued or not			return (targetFloors.indexOf(floor) >= 0);		}		public function processFloor():void {			var i;			//Let people off the elevator first			for(i = 0; i < people.length; i++) {				//If their target floor is here				if(people[i].targetFloor == currentFloor) {					//Remove them from the elevator					people[i].exitElevator(currentFloor);					removePerson(people[i--]);				}			}			//Allow boarding			for(i = 0; i < currentFloor.people.length; i++) {				if(people.length >= capacity) {					//Trigger FULL event, no more space in elevator					EventDispatcher.dispatcher.dispatchEvent(new ElevatorEvent(ElevatorEvent.FULL, { elevator: this, floor: currentFloor, person: currentFloor.people[i] }));					break;				}				//Make sure the person wants to get on the elevator				if(currentFloor.people[i].state == PersonState.ENTERING || currentFloor.people[i].state == PersonState.LEAVING) {					//Make sure going the right direction					if((currentFloor.people[i].targetFloor.index > currentFloor.index && (targetFloors.length <= 0 || isRising())) ||						(currentFloor.people[i].targetFloor.index < currentFloor.index && (targetFloors.length <= 0 || isFalling()))) {						addPerson(currentFloor.people[i]);						currentFloor.people[i].boardElevator(this);						currentFloor.people.splice(i--, 1); //Floor member count decremented					}				}			}		}		public function isRising():Boolean {			//TODO: Check this, probably should be nextFloor()?			//Return true if the next target floor is above this one			return (targetFloors.length > 0 && targetFloors[0].index > currentFloor.index);		}		public function isFalling():Boolean {			//TODO: Check this, probably should be nextFloor()?			//Return true if the next target floor is below this one			return (targetFloors.length > 0 && targetFloors[0].index < currentFloor.index);		}		public function isIdling():Boolean {			//If the elevator is in a non-moving state			return (state == ElevatorState.IDLE || state == ElevatorState.WAITING || state == ElevatorState.RETURNING);		}		public function comparePriority(otherElevator:Elevator, targetFloor:Floor, upwards:Boolean):Elevator {			var self = this;			//Returns the beest elevator given a target floor, and the direction towards that floor. Swap out this compare function with your own :)			var genericCompare = function() {				if(!otherElevator || otherElevator == self || !targetFloor)					return self;				var nextFloor1 = self.nextFloor();				var nextFloor2 = otherElevator.nextFloor();				var distance1 = targetFloor.index - self.currentFloor.index;				var distance2 = targetFloor.index - otherElevator.currentFloor.index;				//Perform some basic tests to see which elevator is best				if(self.isHeadingTowards(targetFloor, upwards) && otherElevator.isHeadingTowards(targetFloor, upwards)) {					if(self.hasQueued(targetFloor)) {						return self; //This elevator already has the floor queued					} else if(otherElevator.hasQueued(targetFloor)) {						return otherElevator; //This elevator already has the floor queued					} else {						return (Math.abs(distance1) <= Math.abs(distance2)) ? self : otherElevator; //Choose the closer elevator					}				} else if(self.isHeadingTowards(targetFloor, upwards)) {					if(otherElevator.isFree()) {						return (Math.abs(distance1) <= Math.abs(distance2)) ? self : otherElevator; //Choose the closer elevator					} else {						return self; //This elevator is available					}				} else if(otherElevator.isHeadingTowards(targetFloor, upwards)) {					if(self.isFree()) {						return (Math.abs(distance1) <= Math.abs(distance2)) ? self : otherElevator; //Choose the closer elevator					} else {						return otherElevator; //Other elevator is available					}				} else if(self.isFree() && otherElevator.isFree()) {					return (Math.abs(distance1) <= Math.abs(distance2)) ? self : otherElevator; //Choose the closer elevator				} else if(self.isFree()) {					return self; //Other elevator must be busy				} else if(otherElevator.isFree()) {					return otherElevator; //This elevator must be busy				} else {					//Debug.console.warn('Hm.... Some state was not managed in Elevator.comparePriority() ', self);					return null;				}			};			return genericCompare();		}	}}