/** * FAO Aaron * Oliver to add following methods so as to give the class all the functionality of both Array and Object classes * (starred classes a priority) * - concat* (merge?) * - every* * - filter* * - indexOf* * - lastIndexOf* * - joinKeys * - joinValues * - map* * - reverse* * - some * - sort* * - sortOn* *  * Oliver - 07-02-2009 */package net.guttershark.util.collections {	import flash.utils.Proxy;	import flash.utils.flash_proxy;	final public class OrderedDictionary2 extends Proxy 	{		private var memberValueHash:Object = {};		private var memberIndexHash:Object = {};		private var memberNameArray:Array = [];		private var isNumeric:RegExp = /^[0-9]*$/;		/* PUBLIC methods		----------------------------------------------------------------------------------------------*/		/**		 * Adds one or more elements to the end of an ordered dictionary and returns the new length of the array.		 * 		 * @param name The key identifier.		 * @param value The value to store.		 */		public function push(name:*, value:*):int		{			if (name in memberValueHash == false) 			{				var last:int = memberNameArray.length;				memberIndexHash[name] = last;				memberNameArray[last] = name;			}			memberValueHash[name] = value;						return memberNameArray.length;		}		/**		 * Removes the last element from an ordered dictionary and returns the value of that element.		 */		public function pop():*		{			var name:* = memberNameArray.pop();			var value:* = memberValueHash[name];						delete memberIndexHash[name];			delete memberValueHash[name];						return value;		}		/**		 * Removes the first element from an ordered dictionary and returns that element.		 */		public function shift():*		{			var name:* = memberNameArray.shift();			var value:* = memberValueHash[name];									delete memberIndexHash[name];			delete memberValueHash[name];						for(name in memberIndexHash) memberIndexHash[name]--;						return value;		}		/**		 * Adds one or more elements to the beginning of an ordered dictionary and returns the new length of the array.		 * 		 * @param name The key name.		 * @param value The value to store.		 */		public function unshift(name:*,value:*):int		{			for(name in memberIndexHash) memberIndexHash[name]++;			memberIndexHash[name] = 0;			memberValueHash[name] = value;			memberNameArray.unshift(name);						return memberNameArray.length;		}		/**		 * Remove multiple items from the ordered dictionary.		 * 		 * @param startIndex The start index to delete from.		 * @param deleteCound The number of items to delete.		 */		public function splice(startIndex:int,deleteCount:int):void		{			var name:*;			var i:int = startIndex;			for (;i == (startIndex + deleteCount); i++)			{				name = memberNameArray[i];				delete this[name];			}		}		/**		 * Remove objects by multiple keys.		 * 		 * @param ...keys The keys to delete.		 */		public function spliceByKeys(...keys):void		{			var i:int = 0;			var num:int = keys.length;			for(;i < num; i++) 			{ 				delete this[keys[i]]; 			}		}		/**		 * Dispose of this ordered dictionary.		 */		public function dispose():void		{			memberNameArray = [];			memberIndexHash = {};			memberValueHash = {};		}		/* ACCESSOR methods		----------------------------------------------------------------------------------------------*/		public function get length():uint 		{			return memberNameArray.length;		}		override flash_proxy function setProperty(name:*, value:*):void 		{			// If 	1) [name] is numeric and low enough to be an extant member of memberIndexHash			// And	2) [value] is in memberValueHash			// Then update the index for [value] to [name]			// In any other case throw an error: we lack a key to relate memberNameArray to memberValueHash and memberIndexHash			if(isNumeric.test(name))			{				name = int(name);				if(name < memberNameArray.length) 				{					for(var k:* in memberValueHash)					{						if(memberValueHash[k] == value) 						{							memberNameArray[name] = k;							memberIndexHash[k] = name;						}					}				}				else throw new ArgumentError("You must supply a non-numeric index to add a new value");			}			else			{						if (name in memberValueHash == false) 				{					var last:uint = memberNameArray.length;					memberIndexHash[name] = last;					memberNameArray[last] = name;				}				memberValueHash[name] = value;			}		}		override flash_proxy function getProperty(name:*):* 		{			if(isNumeric.test(name) && int(name) < memberNameArray.length)			{				name = memberNameArray[name];			}			return memberValueHash[name];		}		override flash_proxy function callProperty(name:*, ...rest):* 		{			if (memberValueHash[name] is Function)			{				return memberValueHash[name].apply(null, rest);			}			return null;		}		override flash_proxy function hasProperty(name:*):Boolean 		{			return name in memberValueHash;		}		override flash_proxy function deleteProperty(name:*):Boolean 		{			var index:int = -1;			if(isNumeric.test(name) && int(name) < memberNameArray.length)			{				index = name;				name = memberNameArray[index];			}			if (name in memberValueHash)			{				if(index < 0) 				{ 					index = memberIndexHash[name]; 				}												memberNameArray.splice(index, 1);				var last:uint = memberNameArray.length;				while(index < last)				{					memberIndexHash[memberNameArray[index]]--;					index++;				}				delete memberValueHash[name];				delete memberIndexHash[name];				return true;			}			return false;		}		override flash_proxy function nextNameIndex(index:int):int 		{			return (index < memberNameArray.length) ? index + 1 : 0;		}		override flash_proxy function nextName(index:int):String 		{			return memberNameArray[index - 1];		}		override flash_proxy function nextValue(index:int):* 		{			return memberValueHash[memberNameArray[index - 1]];		}		override flash_proxy function getDescendants(name:*):* 		{			return null;		}		override flash_proxy function isAttribute(name:*):Boolean 		{			return false;		}	}}