//回転する円class Circle extends RigidBody {		//半径	public var radius:Number = 50;		//角度を保存するための円周上の点	private var rim:Vector;		//点rimにおける接線ベクトル	private var tan:Vector;		//二つの数字の組	private var range:Object;		function Circle() {	}		//各種物理特性を設定する	public function init(x, y, rotation, radius, mass, elasticity, friction):Void {		super.init(x,y,mass,elasticity,friction);				rim = new Vector(Math.cos(rotation), Math.sin(rotation));		tan = new Vector(0, 0);				this.radius = radius;		_width = _height = radius*2;				range = new Object();		range.min = 0;		range.max = 0;	}		//スーパークラスで並進運動した後、角度を更新する	public function update():Void {		super.update();				//rimに接線方向の速度を足す		rim.plusEquals(tan);				//円周上に乗るよう補正する		var clen:Number = Math.sqrt(rim.x * rim.x + rim.y * rim.y);		var diff:Number = (clen - radius) / clen;		rim.x -= rim.x * diff;		rim.y -= rim.y * diff;				//新しいrimを元にムービークリップの角度を更新する		_rotation = Math.atan2(rim.y, rim.x)*180/Math.PI;	}		//衝突応答	public function resolve(mtd:Vector, vel:Vector, normal:Vector, depth:Number, order:Number):Void {				//スーパークラスにて、交わっている状態から接している状態へ位置を移動させる		super.resolve(mtd, vel, normal, depth, order);				//点rimにおける接線ベクトルを更新		tan.x = -rim.y;		tan.y = rim.x;		tan = tan.normalize();				//右回転か左回転かを考慮		var n = normal.mult(sign(depth * order));				//法線と速度が直行しているほど、結果として多く回転		var cp:Number = velocity.cross(n);		tan.multEquals(cp);	}		//符号を返す	private function sign(val:Number):Number {		if (val < 0) return -1		return 1;	}		//ベクトルに射影したときの影の範囲を返す	public function getProjection(v:Vector):Object {		var c:Number = position.dot(v);		range.min = c - radius;		range.max = c + radius;		return range;	}}