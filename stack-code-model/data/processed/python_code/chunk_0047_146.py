package gs.managers{	import flash.display.DisplayObject;	import flash.display.DisplayObjectContainer;	import flash.display.Sprite;	import flash.display.Stage;	import flash.geom.Point;	/**	 * The LayoutManager class provides shortcuts for many alignment and	 * layering operations.	 * 	 * <p>DisplayObjects must have their registration point at 0,0 in	 * order for the align / stage align methods to function correctly. Otherwise	 * you'll see shifts in what is expected.</p>	 * 	 * <p>The LayoutManager can also align objects to inner and outer	 * edges of target display objects.</p>	 * 	 * @example	Using a layout manager from a CoreClip.	 * <listing>		 * public class MyClip extends CoreClip	 * {	 *     public function MyClip()	 *     {	 *         super(); //critical	 *         	 *         var mc1:MovieClip = new MovieClip();	 *         //draw vector box in mc1 here...	 *        	 *         var mc2:MovieClip = new MovieClip();	 *         //draw vector box in mc2 here...	 *         	 *         var mc3:MovieClip = new MovieClip();	 *         //draw vector box in mc3 here...	 *         	 *         lm.addChildren(mc1,mc2,mc3); //shortcut to add multiple children.	 *         	 *         lm.bringInFront(mc1,mc2); //moves mc1 in front of mc2.	 *         lm.sendToBack(mc1); //sends mc1 all the way to the back.	 *         lm.bringForward(mc2); //brings mc2 forward (in front of mc3).	 *     }	 * }	 * </listing>	 * 	 * <p><b>Examples</b> are in the <a target="_blank" href="http://gitweb.codeendeavor.com/?p=guttershark.git;a=summary">guttershark</a> repository.</p>	 * 	 * <script src="http://mint.codeendeavor.com/?js" type="text/javascript"></script>	 */	final public class LayoutManager	{				/**		 * An alignment mode that causes the inner edges to be aligned.		 */		public static var ALIGN_INNER:String = "inner";				/**		 * An alignment mode that causes the outer edges to be aligned.		 */		public static var ALIGN_OUTER:String = "outer";				/**		 * The container in which layering operations will occur.		 */		protected var container:DisplayObjectContainer;				/**		 * zero point for local to local translations.		 */		private static var ZeroPoint:Point;				/**		 * The stage width from the versy first time a layout manager instance was created.		 */		private static var FirstStageWidth:int;				/**		 * The stage height from the versy first time a layout manager instance was created.		 */		private static var FirstStageHeight:int;				/**		 * a reference to the stage		 */		public static var StageRef:Stage;				/**		 * Whether or not to use whole pixels on for x and y coordinates.		 */		public static var wholePixels:Boolean = true;				/**		 * Ignore the stage align property and correctly translate		 * stage alignment operations to the actual stage viewport -		 * meaning if the stage.align property is anything other		 * than undefined or TOP_LEFT, correctly translate the 		 * positioning offsets that occur when setting x and y.		 */		public static var ignoreStageAlign:Boolean = true;				/**		 * Set a reference to the stage.		 * 		 * @param st The stage instance.		 */		public static function SetStageReference(st:Stage):void		{			if(!st)throw new Error("The {stage} parameter cannot be null.");			StageRef=st;			FirstStageHeight=st.stageHeight;			FirstStageWidth=st.stageWidth;		}				/**		 * Constructor for LayoutManager instances. 		 */		public function LayoutManager(target:DisplayObjectContainer)		{			if(!target) throw new Error("The supplied target display container cannot be null");			container=target;			if(!ZeroPoint)ZeroPoint=new Point(0,0);			if(!FirstStageHeight&&container.stage)			{				FirstStageHeight=container.stage.stageHeight;				FirstStageWidth=container.stage.stageWidth;				StageRef=container.stage;			}		}				/**		 * Gets the properties needed for container coordinate translations.		 * 		 * @param target The target display object.		 * @param relativeTo The relative to display object.		 */		private function getProps(target:DisplayObject,relativeTo:DisplayObject):Object		{			var props:Object = {};			props.iw=target.width;			props.ih=target.height;			props.tw=relativeTo.width;			props.th=relativeTo.height;			props.tgp=relativeTo.localToGlobal(ZeroPoint);			var added:Boolean;			var toggledv:Boolean;			if(!target.parent)			{				if(target.visible)				{					target.visible=false;					toggledv=true;				}				StageRef.addChild(target);				added=true;			}			props.ilp=target.parent.globalToLocal(props.tgp);			if(added)			{				StageRef.removeChild(target);				if(toggledv) target.visible=true;			}			return props;		}				private function checkTargetAndRel(target:DisplayObject,relativeTo:DisplayObject):void		{			if(!target)throw new ArgumentError("Parameter {target} cannot be null.");			if(!relativeTo)throw new ArgumentError("Parameter {target} cannot be null.");		}				private function checkTarget(target:DisplayObject):void		{			if(!target)throw new ArgumentError("Parameter {target} cannot be null.");		}				/**		 * Bring a target display object in front of another display object.		 * 		 * @param target The target display object to re-layer.		 * @param relativeTo The display object in which the target will be brought in front of.		 */		public function bringInFront(target:DisplayObject,relativeTo:DisplayObject):void		{			checkTargetAndRel(target,relativeTo);			var index:int=container.getChildIndex(relativeTo);			if(index<container.getChildIndex(target)) index+=1;			if(index!=-1)container.setChildIndex(target,index);		}				/**		 * Send a target display object behind another display object.		 * 		 * @param target The target display object to re-layer.		 * @param relativeTo The display object in which the target will be moved behind.		 */		public function sendBehind(target:DisplayObject,relativeTo:DisplayObject):void		{			checkTargetAndRel(target,relativeTo);			if(!container||!target||!relativeTo)return;			var index:int=container.getChildIndex(relativeTo);			if(index!=-1)container.setChildIndex(target,index);		}				/**		 * Bring a display object forward 1 layer.		 * 		 * @param target The target display object.		 */		public function bringForward(target:DisplayObject):void		{			checkTarget(target);			var index:int = container.getChildIndex(target)+1;			if(index==container.numChildren)return;			if(index!=-1)container.setChildIndex(target,index);		}				/**		 * Send the target display object backward 1 layer.		 * 		 * @param target The target display object.		 */		public function sendBackward(target:DisplayObject):void		{			checkTarget(target);			var index:int=Math.max(0,container.getChildIndex(target)-1);			container.setChildIndex(target,index);			if(index!=-1)container.setChildIndex(target,index);		}				/**		 * Bring the target display object to the top most layer.		 * 		 * @param target The target display object.		 */		public function bringToFront(target:DisplayObject):void		{			checkTarget(target);			var index:int = container.numChildren - 1;			container.setChildIndex(target, index);			if(index != -1) container.setChildIndex(target, index);		}				/**		 * Send the target display object to bottom most layer.		 * 		 * @param target The target display object.		 */		public function sendToBack(target:DisplayObject):void		{			checkTarget(target);			container.setChildIndex(target, 0);		}				/**		 * Returns an array of all the children on the targets		 * display list.		 * 		 * @param target The target display object.		 */		public function getAllChildren(target:Sprite):Array		{			checkTarget(target);			var list:Array=[];			var l:int=target.numChildren;			if(l==0)return list;			var i:int=0;			for(;i<l;i++)list.push(target.getChildAt(int(i)));			return list;		}		/**		 * Add all children specified to the display list.		 * 		 * @param ...children An array of display objects to add.		 */		public function addChildren(...children:Array):void		{			if(!children || children.length < 1) throw new ArgumentError("Parameter {children} cannot be null or empty");			var child:DisplayObject;			for each(child in children) container.addChild(child);		}				/**		 * Add all children specified onto the display list of the target container.		 * 		 * @param target A display object to add the spefified children onto.		 * @param ...children An array of display objects to add.		 */		public function addChildrenTo(target:DisplayObjectContainer,...children:Array):void		{			checkTarget(target);			if(!children || children.length < 1) throw new ArgumentError("Parameter {children} cannot be null or empty");			var child:DisplayObject;			for each(child in children) target.addChild(child);		}				/**		 * Remove all children from the display list.		 */		public function removeAllChildren():void		{			if(container.numChildren<1) return;			var i:int=0;			var l:int=container.numChildren;			for(;i<l;i++)container.removeChildAt(0);		}		/**		 * Remove all children specified from the display list.		 * 		 * @param ...children The children to remove.		 */		public function removeChildren(...children:Array):void		{			if(!children || children.length < 1) throw new ArgumentError("Parameter {children} cannot be null or empty");			var child:DisplayObject;			for each(child in children)container.removeChild(child);		}				/**		 * Remove specified children from the target DisplayObjectContainer's display list.		 * 		 * @param target A display object to remove the spefified children from.		 * @param ...children The children to remove.		 */		public function removeChildrenFrom(target:DisplayObjectContainer,...children:Array):void		{			checkTarget(target);			if(!children || children.length < 1) throw new ArgumentError("Parameter {children} cannot be null or empty");			var child:DisplayObject;			for each(child in children)target.removeChild(child);		}				/**		 * Remove all children from the display list of the specified target object.		 * 		 * @param target The target display object container whose children will be removed.		 */		public function removeAllChildrenFrom(target:DisplayObjectContainer):void		{			checkTarget(target);			if(target.numChildren<1) return;			var i:int=0;			var l:int=target.numChildren;			for(;i<l;i++)target.removeChildAt(0);		}				/**		 * Align the target display object centered on the x coordinate relatively		 * to another display object.		 * 		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display object to align.		 */		public function alignXCenter(relativeTo:DisplayObject, ...targets):void		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTargetAndRel(target,relativeTo);				var props:Object = getProps(target, relativeTo);				var targetX:Number = props.ilp.x + ((props.tw - props.iw) / 2);				target.x = (wholePixels) ? Math.round(targetX) : targetX;			}		}				/**		 * Align the target display object centered on the y coordinate relatively		 * to another display object.		 * 		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignYCenter(relativeTo:DisplayObject,...targets):void 		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTargetAndRel(target,relativeTo);				var props:Object = getProps(target, relativeTo);				var targetY:Number = props.ilp.y + ((props.th - props.ih) / 2);				target.y = (wholePixels) ? Math.round(targetY) : targetY;			}		}				/**		 * Align the target display object to the right edge of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display object to align.		 */		public function alignRight(alignMode:String,relativeTo:DisplayObject,...targets):void		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTargetAndRel(target,relativeTo);				var props:Object=getProps(target,relativeTo);				var targetX:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetX=props.ilp.x+props.tw;						break;					case LayoutManager.ALIGN_INNER:					default:						targetX=props.ilp.x+(props.tw-props.iw);						break;				}				target.x=(wholePixels)?Math.round(targetX):targetX;			}		}				/**		 * Align the target display object to the left edge of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner)		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display object to align.		 */			public function alignLeft(alignMode:String,relativeTo:DisplayObject,...targets):void		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTargetAndRel(target,relativeTo);				var props:Object = getProps(target, relativeTo);				var targetX:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetX=props.ilp.x-props.iw;						break;					case LayoutManager.ALIGN_INNER:					default:						targetX=props.ilp.x;						break;				}				target.x=(wholePixels)?Math.round(targetX):targetX;			}		}				/**		 * Align a display object to the top edge of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display object to align.		 */		public function alignTop(alignMode:String,relativeTo:DisplayObject,...targets):void		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTargetAndRel(target,relativeTo);				var props:Object=getProps(target, relativeTo);				var targetY:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetY=props.ilp.y-props.ih;						break;					case LayoutManager.ALIGN_INNER:					default:						targetY=props.ilp.y;						break;				}				target.y=(wholePixels)?Math.round(targetY):targetY;			}		}				/**		 * Align a display object to the bottom edge of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignBottom(alignMode:String,relativeTo:DisplayObject,...targets):void		{			if(!targets)return;			if(targets && (targets[0] is Array))targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[int(i)];				checkTargetAndRel(target,relativeTo);				var props:Object = getProps(target, relativeTo);				var targetY:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetY=props.ilp.y+props.th;						break;					case LayoutManager.ALIGN_INNER:					default:						targetY=props.ilp.y+(props.th-props.ih);						break;				}				target.y=(wholePixels)?Math.round(targetY):targetY;			}		}				/**		 * Align a display object to the dead center of another display object.		 * 		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignCenter(relativeTo:DisplayObject,...targets):void		{			alignXCenter(relativeTo,targets);			alignYCenter(relativeTo,targets);		}				/**		 * Align a display object to the top center of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignTopCenter(alignMode:String,relativeTo:DisplayObject,...targets):void		{			alignXCenter(relativeTo,targets);			alignTop(alignMode,relativeTo,targets);		}				/**		 * Align a display object to the bottom center of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignBottomCenter(alignMode:String,relativeTo:DisplayObject,...targets):void		{			alignXCenter(relativeTo,targets);			alignBottom(alignMode,relativeTo,targets);		}		/**		 * Align a display object to the top left corner of another display object.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param target The target display objects to align.		 */		public function alignTopLeft(alignModeX:String,alignModeY:String,relativeTo:DisplayObject,...targets):void		{			alignLeft(alignModeX,relativeTo,targets);			alignTop(alignModeY,relativeTo,targets);		}				/**		 * Align a display object to the left middle of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignMiddleLeft(alignMode:String,relativeTo:DisplayObject,...targets):void		{			alignLeft(alignMode,relativeTo,targets);			alignYCenter(relativeTo,targets);		}				/**		 * Align a display object to the bottom left corner of another display object.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignBottomLeft(alignModeX:String,alignModeY:String,relativeTo:DisplayObject,...targets):void		{			alignLeft(alignModeX,relativeTo,targets);			alignBottom(alignModeY,relativeTo,targets);		}				/**		 * Align a display object to the top right corner of another display object.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignTopRight(alignModeX:String,alignModeY:String,relativeTo:DisplayObject,...targets):void		{			alignRight(alignModeX,relativeTo,targets);			alignTop(alignModeY,relativeTo,targets);		}				/**		 * Align a display object to the right middle of another display object.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param relativeTo The target display object that target will be aligned to.		 * @param targets The target display objects to align.		 */		public function alignMiddleRight(alignMode:String,relativeTo:DisplayObject,...targets):void		{			alignRight(alignMode,relativeTo,targets);			alignYCenter(relativeTo,targets);		}				/**		 * Align a display object to the bottom right corner of another display object.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param target The target display object to align.		 * @param relativeTo The target display object that target will be aligned to.		 */		public function alignBottomRight(alignModeX:String,alignModeY:String,relativeTo:DisplayObject,...targets):void		{			alignRight(alignModeX,relativeTo,targets);			alignBottom(alignModeY,relativeTo,targets);		}		/**		 * Checks for a stage reference, if there is one, updates the properties needed		 * for stage align methods otherwise throws an error because the		 * container must be on the stage.		 */		private function checkForStageAndUpdate():void		{			if(!container.stage)throw new Error("The container used for the layout manager must be on the stage, before using any of the stage align methods.");			if(!FirstStageHeight)			{				FirstStageHeight=container.stage.stageHeight;				FirstStageWidth=container.stage.stageWidth;				StageRef=container.stage;			}		}				/**		 * Gets common properties for the target item.		 * 		 * @param item The target display object.		 */		private function propsForStageAligns(item:DisplayObject):Object		{			checkForStageAndUpdate();			var props:Object = {};			props.iw=item.width;			props.ih=item.height;			return props;		}				/**		 * Takes care of updating the X coordinate for adjustments to		 * stage size by resize, because if the stage.align property		 * is anything other than top left, the coordinates get		 * shifted strangely.		 */		private function updatePointXForStageAdjustments(p:Point):Point		{			if(StageRef.stageHeight == FirstStageHeight && StageRef.stageWidth == FirstStageWidth) return p;			if(!(StageRef.align || StageRef.align == "T" || StageRef.align == "B"))			{				if(FirstStageWidth < StageRef.stageWidth) p.x -= (StageRef.stageWidth - FirstStageWidth) / 2;				else p.x += (FirstStageWidth - StageRef.stageWidth) / 2;			}			else if(StageRef.align == "R" || StageRef.align == "TR" || StageRef.align == "BR")			{				if(FirstStageWidth < StageRef.stageWidth) p.x -= (StageRef.stageWidth - FirstStageWidth);				else p.x += (FirstStageWidth - StageRef.stageWidth);			}			if(wholePixels) p.x = Math.round(p.x);			return p;		}				/**		 * Takes care of updating the Y coordinate for adjustments to		 * stage size by resize, because if the stage.align property		 * is anything other than top left, the coordinates get		 * shifted strangely.		 */		private function updatePointYForStageAdjustments(p:Point):Point		{			if(StageRef.stageHeight == FirstStageHeight && StageRef.stageWidth == FirstStageWidth) return p;			if(!(StageRef.align) || StageRef.align == "L" || StageRef.align == "R")			{				if(FirstStageHeight < StageRef.stageHeight) p.y -= (StageRef.stageHeight - FirstStageHeight) / 2;				else p.y += (FirstStageHeight - StageRef.stageHeight) / 2;			}			else if(StageRef.align == "BL" || StageRef.align == "BR" || StageRef.align == "B")			{				if(FirstStageHeight < StageRef.stageHeight) p.y -= (StageRef.stageHeight - FirstStageHeight);				else p.y += (FirstStageHeight - StageRef.stageHeight);			}			if(wholePixels) p.y = Math.round(p.y);			return p;		}				/**		 * Align the target display object centered on the x coordinate relatively		 * to the stage.		 * 		 * @param target The target display objects to align.		 */		public function stageAlignXCenter(...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				if(!target.parent)continue;				var props:Object=propsForStageAligns(target);				var nx:int=(StageRef.stageWidth-props.iw)/2;				var p:Point=new Point(nx,0);				var np:Point=target.parent.globalToLocal(p);				if(ignoreStageAlign)np=updatePointXForStageAdjustments(np);				target.x=np.x;			}		}				/**		 * Align the target display object centered on the y coordinate relatively		 * to the stage.		 * 		 * @param targets The target display objects to align.		 */		public function stageAlignYCenter(...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				if(!target.parent)continue;				var props:Object=propsForStageAligns(target);				var ny:int=(StageRef.stageHeight-props.ih)/2;				var p:Point=new Point(0,ny);				var np:Point=target.parent.globalToLocal(p);				if(ignoreStageAlign)np=updatePointYForStageAdjustments(np);				target.y=np.y;			}		}				/**		 * Align the target display object to the right edge of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignRight(alignMode:String,...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				if(!target.parent)continue;				var props:Object=propsForStageAligns(target);						var nx:int;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						nx=StageRef.stageWidth;						break;					case LayoutManager.ALIGN_INNER:					default:						nx=(StageRef.stageWidth-props.iw);						break;				}				var p:Point=new Point(nx,0);				var np:Point=target.parent.globalToLocal(p);				if(ignoreStageAlign)np=updatePointXForStageAdjustments(np);				target.x=np.x;			}		}				/**		 * Align the target display object to the left edge of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignLeft(alignMode:String,...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				if(!target.parent)continue;				var p:Point=new Point(0,0);				var np:Point=target.parent.globalToLocal(p);				if(ignoreStageAlign)np=updatePointXForStageAdjustments(np);				var targetX:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetX=(np.x-target.width);						break;					case LayoutManager.ALIGN_INNER:					default:						targetX=np.x;						break;				}				target.x=(wholePixels)?Math.round(targetX):targetX;			}		}				/**		 * Align the target display object to the bottom edge of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignBottom(alignMode:String,...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				if(!target.parent)continue;				var props:Object=propsForStageAligns(target);				var ny:int;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						ny=StageRef.stageHeight;						break;					case LayoutManager.ALIGN_INNER:					default:						ny=(StageRef.stageHeight-props.ih);						break;				}				var p:Point=new Point(0,ny);				var np:Point=target.parent.globalToLocal(p);				if(ignoreStageAlign)np=updatePointYForStageAdjustments(np);				target.y=np.y;			}		}		/**		 * Align the target display object to the top edge of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignTop(alignMode:String,...targets):void		{			if(targets && (targets[0] is Array)) targets=targets[0];			var i:int=0;			var l:int=targets.length;			var target:*;			for(;i<l;i++)			{				target=targets[i];				checkTarget(target);				if(!target.parent)return;				var p:Point=target.parent.globalToLocal(ZeroPoint);				if(ignoreStageAlign)p=updatePointYForStageAdjustments(p);				var targetY:Number;				switch(alignMode)				{					case LayoutManager.ALIGN_OUTER:						targetY=(p.y-target.height);						break;					case LayoutManager.ALIGN_INNER:					default:						targetY=p.y;						break;				}				target.y=(wholePixels)?Math.round(targetY):targetY;			}		}				/**		 * Align the target display object to the dead center of the stage.		 * 		 * @param targets The target display objects to align.		 */		public function stageAlignCenter(...targets):void		{			stageAlignXCenter(targets);			stageAlignYCenter(targets);		}				/**		 * Align the target display object to the right middle of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param target The target display objects to align.		 */		public function stageAlignMiddleRight(alignMode:String,...targets):void		{			stageAlignRight(alignMode,targets);			stageAlignYCenter(targets);		}				/**		 * Align the target display object to the left middle of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param target The target display objects to align.		 */		public function stageAlignMiddleLeft(alignMode:String,...targets):void		{			stageAlignLeft(alignMode,targets);			stageAlignYCenter(targets);		}				/**		 * Align the target display object to the top center of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignTopCenter(alignMode:String,...targets):void		{			stageAlignTop(alignMode,targets);			stageAlignXCenter(targets);		}				/**		 * Align the target display object to the bottom center of the stage.		 * 		 * @param alignMode Inner or outer align (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignBottomCenter(alignMode:String,...targets):void		{			stageAlignBottom(alignMode,targets);			stageAlignXCenter(targets);		}				/**		 * Align the target display object to the top right corner of the stage.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignTopRight(alignModeX:String,alignModeY:String,...targets):void		{			stageAlignRight(alignModeX,targets);			stageAlignTop(alignModeY,targets);		}				/**		 * Align the target display object to the bottom right corner of the stage.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignBottomRight(alignModeX:String,alignModeY:String,...targets):void		{			stageAlignBottom(alignModeY,targets);			stageAlignRight(alignModeX,targets);		}				/**		 * Align the target display object to the bottom left corner of the stage.		 * 		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 * @param targets The target display objects to align.		 */		public function stageAlignBottomLeft(alignModeX:String,alignModeY:String,...targets):void		{			stageAlignLeft(alignModeX,targets);			stageAlignBottom(alignModeY,targets);		}				/**		 * Align the target display object to the top left corner of the stage.		 * 		 * @param target The target display object to align.		 * @param alignModeX x-Axis alignment: inner or outer (default: inner).		 * @param alignModeX y-Axis alignment: inner or outer (default: inner).		 */		public function stageAlignTopLeft(alignModeX:String,alignModeY:String,...targets):void		{			stageAlignTop(alignModeY,targets);			stageAlignLeft(alignModeX,targets);		}		/**		 * Returns the stage dead center point.		 */		public function getStageDeadCenterPoint():Point		{			return new Point(StageRef.stageWidth / 2, StageRef.stageHeight / 2);		}				/**		 * Align any objects in a vertical stack (column) on y.		 * 		 * <p>You can supply these options:</p>		 * 		 * <ul>		 * <li>padding - An amount of padding to add between each object.</li>		 * <li>visiblesOnly - whether or not each object should be visible.</li>		 * <li>visiblesAndAlphaOnly - whether or not each object should be visible, and an alpha of 1.</li>		 * </ul>		 * 		 * @param options An object with properties (see above).		 * @param ...objs Rest style list of objects.		 */		public function alignColumn(options:Object,...objs:Array):void		{			if(objs[0] is Array)objs=objs[0];			var i:int=0;			var l:int=objs.length;			if(!objs)return;			if(!options)			{				trace("WARNING: The options object was null. Not doing anything.");				return;			}			if(objs[0] is Array)objs=objs[0];			if(objs.length<2)			{				trace("WARNING: alignColumn needs more than 1 object. Not doing anything.");				return;			}			if(options.visiblesOnly)for(;i<l;i++)if(!objs[int(i)].visible)objs.splice(i,1);			i=0;			if(options.visiblesAndAlphaOnly)for(;i<l;i++)if(!objs[int(i)].visible&&objs[int(i)].alpha!=1)objs.splice(i,1);			if(objs.length<1)return;			if(!options.padding)options.padding=0;			var prevobj:*;			var curobj:*;			i=0;			for(;i<l;i++)			{				if(!objs[int(i)])continue;				if(!prevobj)				{					prevobj=objs[int(i)];					continue;				}				curobj=objs[int(i)];				curobj.y=prevobj.y+prevobj.height+options.padding;				prevobj=curobj;			}		}				/**		 * Dispose of this layout manager.		 */		public function dispose():void		{			container=null;		}	}}