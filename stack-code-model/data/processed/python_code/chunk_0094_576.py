/** *  (c) VARIANTE <http://variante.io> * *  This software is released under the MIT License: *  http://www.opensource.org/licenses/mit-license.php */package io.variante.helpers{    import flash.display.DisplayObject;    import flash.display.DisplayObjectContainer;    import flash.display.Stage;    import flash.display.StageAlign;    import flash.display.StageQuality;    import flash.display.StageScaleMode;    import flash.events.Event;    import flash.ui.ContextMenu;    import flash.ui.ContextMenuItem;    import flash.utils.Dictionary;    import io.variante.transitions.easing.Quart;    import io.variante.transitions.VSTween;    /**     * A static class used for positioning DisplayObjects with respect to     * the stage.     *     * Director provides the following object aligning features:     *      TOP               -- align to the top of the stage     *      BOTTOM            -- align to the bottom of the stage     *      LEFT              -- align to the left of the stage     *      RIGHT             -- align to the right of the stage     *      TOP_LEFT          -- align to top left of the stage     *      TOP_RIGHT         -- align to top right of the stage     *      BOTTOM_LEFT       -- align to bottom left of the stage     *      BOTTOM_RIGHT      -- align to bottom right of the stage     *      ABSOLUTE_CENTER   -- align to absolute center of the stage     *      HORIZONTAL_CENTER -- center object in the x-axis     *      VERTICAL_CENTER   -- center object in the y-axis     *      TOP_CENTER        -- center object in the x-axis at the top of the stage     *      BOTTOM_CENTER     -- center object in the x-axis at the bottom of the stage     *      LEFT_CENTER       -- center object in the y-axis at the left of the stage     *      RIGHT_CENTER      -- center object in the y-axis at the right of the stage     *     * @example Director.setAlign(mc, Director.TOP_LEFT, true); // object 'mc' is automatically     *          aligned to the top left of the stage since param 'reference' is not specified     *          and therefore is by default the stage. No tweening during repositioning of     *          object because 'animated' param is not specified and is by default false.     */    public final class VSDirector    {        /**         * List of available align settings of directed DisplayObject.         */        public static const TOP:String               = 'topAligned';        public static const BOTTOM:String            = 'bottomAligned';        public static const LEFT:String              = 'leftAligned';        public static const RIGHT:String             = 'rightAligned';        public static const TOP_LEFT:String          = 'topLeftAligned';        public static const TOP_RIGHT:String         = 'topRightAligned';        public static const BOTTOM_LEFT:String       = 'bottomLeftAligned';        public static const BOTTOM_RIGHT:String      = 'bottomRightAligned';        public static const ABSOLUTE_CENTER:String   = 'absoluteCenterAligned';        public static const HORIZONTAL_CENTER:String = 'horizontalCenterAligned';        public static const VERTICAL_CENTER:String   = 'verticalCenterAligned';        public static const TOP_CENTER:String        = 'topCenterAligned';        public static const BOTTOM_CENTER:String     = 'bottomCenterAligned';        public static const LEFT_CENTER:String       = 'leftCenterAligned';        public static const RIGHT_CENTER:String      = 'rightCenterAligned';        /**         * @private         *         * Default top padding of directed DisplayObject, with respect to         * application stage.         */        private static const DEFAULT_TOP_PADDING:Number = 0;        /**         * @private         *         * Default right padding of directed DisplayObject, with respect to         * application stage.         */        private static const DEFAULT_RIGHT_PADDING:Number = 0;        /**         * @private         *         * Default bottom padding of directed DisplayObject, with respect to         * application stage.         */        private static const DEFAULT_BOTTOM_PADDING:Number = 0;        /**         * @private         *         * Default left padding of directed DisplayObject, with respect to         * application stage.         */        private static const DEFAULT_LEFT_PADDING:Number = 0;        /**         * @private         *         * Default auto-align setting of directed DisplayObject, with respect to stage.         */        private static const DEFAULT_ALIGN:String = TOP_LEFT;        /**         * @private         *         * Default animated property of directed DisplayObject.         */        private static const DEFAULT_ANIMATED:Boolean = false;        /**         * @private         * Default animation duration of directed DisplayObject.         */        private static const DEFAULT_DURATION:Number = 0.5;        /**         * @private         *         * Default tween delay of directed DisplayObject.         */        private static const DEFAULT_DELAY:Number = 0;        /**         * @private         *         * Default application stage frame rate.         */        private static const DEFAULT_FRAME_RATE:Number = 60;        /**         * @private         *         * Default application stage quality.         */        private static const DEFAULT_STAGE_QUALITY:String = StageQuality.HIGH;        /**         * @private         *         * Default application stage align.         */        private static const DEFAULT_STAGE_ALIGN:String = StageAlign.TOP_LEFT;        /**         * @private         *         * Default application stage scale mode.         */        private static const DEFAULT_STAGE_SCALE_MODE:String = StageScaleMode.NO_SCALE;        /**         * @private         *         * Default application stage show default context menu option.         */        private static const DEFAULT_SHOW_DEFAULT_CONTEXT_MENU:Boolean = false;        /**         * @private         *         * Storage array of directed objects that are set to auto-align.         */        private static var _autoAlignedObjects:Array;        /**         * @private         *         * Storage array of directed objects that are set to auto fit.         */        private static var _autoFittedObjects:Array;        /**         * @private         *         * Dictionary instance used to store references of directed objects.         */        private static var _dictionary:Dictionary;        /**         * @private         *         * Instance of application stage.         */        private static var _stage:Stage;        /**         * Static initializer.         */        {            _dictionary = new Dictionary(true);        }        /**         * Init function that sets up stage properties.         *         * @param  $target                    Target.         * @param  $framerate                 Stage framerate.         * @param  $quality                   Stage quality.         * @param  $scaleMode                 Stage scale mode.         * @param  $align                     Stage alignment.         * @param  $showDefaultContextMenu    Option to show default context menu.         */        public static function setupStageOf($target:DisplayObjectContainer, $framerate:Number = DEFAULT_FRAME_RATE, $quality:String = DEFAULT_STAGE_QUALITY, $scaleMode:String = DEFAULT_STAGE_SCALE_MODE, $align:String = DEFAULT_STAGE_ALIGN, $showDefaultContextMenu:Boolean = DEFAULT_SHOW_DEFAULT_CONTEXT_MENU):void        {            _stage                        = $target.stage;            _stage.frameRate              = $framerate;            _stage.quality                = $quality;            _stage.scaleMode              = $scaleMode;            _stage.align                  = $align;            _stage.showDefaultContextMenu = $showDefaultContextMenu;            var cm:ContextMenu = new ContextMenu();            var engineVersion:ContextMenuItem = new ContextMenuItem('Powered by VARS');            engineVersion.enabled = false;            cm.customItems.push(engineVersion);            $target.contextMenu = cm;        }        /**         * Sets the align paddings of the target object.         *         * @param $target         * @param $topPadding         * @param $rightPadding         * @param $bottomPadding         * @param $leftPadding         */        public static function setAlignPadding($target:DisplayObject, $topPadding:Number = DEFAULT_TOP_PADDING, $rightPadding:Number = DEFAULT_RIGHT_PADDING, $bottomPadding:Number = DEFAULT_BOTTOM_PADDING, $leftPadding:Number = DEFAULT_LEFT_PADDING ):void        {            _registerObject($target);            _dictionary[$target]['alignTopPadding']    = $topPadding;            _dictionary[$target]['alignRightPadding']  = $rightPadding;            _dictionary[$target]['alignBottomPadding'] = $bottomPadding;            _dictionary[$target]['alignLeftPadding']   = $leftPadding;        }        /**         * Sets the fit paddings of the target object.         *         * @param $target         * @param $topPadding         * @param $rightPadding         * @param $bottomPadding         * @param $leftPadding         */        public static function setFitPadding($target:DisplayObject, $topPadding:Number = DEFAULT_TOP_PADDING, $rightPadding:Number = DEFAULT_RIGHT_PADDING, $bottomPadding:Number = DEFAULT_BOTTOM_PADDING, $leftPadding:Number = DEFAULT_LEFT_PADDING):void        {            _registerObject($target);            _dictionary[$target]['fitTopPadding']   = $topPadding;            _dictionary[$target]['fitRightPadding'] = $rightPadding;            _dictionary[$target]['fitBottomPadding']= $bottomPadding;            _dictionary[$target]['fitLeftPadding']  = $leftPadding;        }        /**         * Sets the align settings of the target object.         *         * @param  $target         Target DisplayObject.         * @param  $type           Align type.         * @param  $autoAlign      Option for auto-align when stage resizes.         * @param  $pivotWidth     Reference width for alignment (if target changes dimensions on runtime).         * @param  $pivotHeight    Reference height for alignment (if target changes dimensions on runtime).         * @param  $reference      Reference DisplayObject for target to align to (defaults to stage).         * @param  $animated       Option to animate the alignment.         * @param  $duration       Duration of animation if $animated is set to true.         * @param  $delay          Delay of animation if $animated is set to true.         * @param  $ease           Ease function of animation if $animated is set to true.         */        public static function setAlignSettings($target:DisplayObject, $type:String = null, $autoAlign:Boolean = false, $pivotWidth:Number = NaN, $pivotHeight:Number = NaN, $reference:Object = null, $animated:Boolean = false, $duration:Number = NaN, $delay:Number = NaN, $ease:Object = null):void        {            _registerObject($target);            var target:Object = _dictionary[$target];            target['alignAnimated'] = $animated;            if ($ease != null)  { target['alignEase']  = $ease;  }            if (!isNaN($delay)) { target['alignDelay'] = $delay; }            if (isNaN($duration))            {                if ($animated)                    target['alignDuration'] = DEFAULT_DURATION;                else                    target['alignDuration'] = 0;            }            else            {                target['alignDuration'] = $duration;            }            setAutoAlign($target, $autoAlign);            if ($reference != null) target['alignReference'] = $reference;            if ($type != null)      target['alignType']      = $type;            target['pivotWidth']  = $pivotWidth;            target['pivotHeight'] = $pivotHeight;        }        /**         * Aligns the target object.         *         * @param  $target         Target DisplayObject.         * @param  $type           Align type.         * @param  $autoAlign      Option for auto-align when stage resizes.         * @param  $pivotWidth     Reference width for alignment (if target changes dimensions on runtime).         * @param  $pivotHeight    Reference height for alignment (if target changes dimensions on runtime).         * @param  $reference      Reference DisplayObject for target to align to (defaults to stage).         * @param  $animated       Option to animate the alignment.         * @param  $duration       Duration of animation if $animated is set to true.         * @param  $delay          Delay of animation if $animated is set to true.         * @param  $ease           Ease function of animation if $animated is set to true.         */        public static function setAlign($target:DisplayObject, $type:String = null, $autoAlign:Boolean = false, $pivotWidth:Number = NaN, $pivotHeight:Number = NaN, $reference:Object = null, $animated:Boolean = false, $duration:Number = NaN, $delay:Number = NaN, $ease:Object = null):void        {            setAlignSettings($target, $type, $autoAlign, $pivotWidth, $pivotHeight, $reference, $animated, $duration, $delay, $ease);            var objProperty:Object    = _dictionary[$target];            var widthProperty:String  = null;            var heightProperty:String = null;            var refWidth:Number       = (isNaN(objProperty['pivotWidth']))  ? $target.width  : objProperty['pivotWidth'];            var refHeight:Number      = (isNaN(objProperty['pivotHeight'])) ? $target.height : objProperty['pivotHeight'];            if (objProperty['alignReference'] == _stage)            {                widthProperty = 'stageWidth';                heightProperty = 'stageHeight';            }            else            {                widthProperty = 'width';                heightProperty = 'height';            }            switch ($type)            {                case TOP:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case BOTTOM:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignReference'][heightProperty] - objProperty['alignBottomPadding'] - refHeight,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case LEFT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: objProperty['alignLeftPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case RIGHT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignReference'][widthProperty] - objProperty['alignRightPadding'] - refWidth,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case TOP_LEFT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'],                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case TOP_RIGHT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignReference'][widthProperty] - objProperty['alignRightPadding'] - refWidth,                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case BOTTOM_RIGHT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignReference'][widthProperty] - objProperty['alignRightPadding'] - refWidth,                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignReference'][heightProperty] - objProperty['alignBottomPadding'] - refHeight,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case BOTTOM_LEFT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                     x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'],                                     y: DisplayObject(objProperty['alignReference']).y + objProperty['alignReference'][heightProperty] - objProperty['alignBottomPadding'] - refHeight,                                     delay: objProperty['alignDelay'],                                     ease: objProperty['alignEase']                                 });                    break;                case HORIZONTAL_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'] - objProperty['alignRightPadding'] + ((objProperty['alignReference'][widthProperty] - refWidth) * 0.5),                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case VERTICAL_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'] - objProperty['alignBottomPadding'] + ((objProperty['alignReference'][heightProperty] - refHeight) * 0.5),                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case ABSOLUTE_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'] - objProperty['alignRightPadding'] + ((objProperty['alignReference'][widthProperty] - refWidth) * 0.5),                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'] - objProperty['alignBottomPadding'] + ((objProperty['alignReference'][heightProperty] - refHeight) * 0.5),                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case TOP_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'] - objProperty['alignRightPadding'] + ((objProperty['alignReference'][widthProperty] - refWidth) * 0.5),                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case BOTTOM_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'] - objProperty['alignRightPadding'] + ((objProperty['alignReference'][widthProperty] - refWidth) * 0.5),                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignReference'][heightProperty] - objProperty['alignBottomPadding'] - refHeight,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case LEFT_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'],                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'] - objProperty['alignBottomPadding'] + ((objProperty['alignReference'][heightProperty] - refHeight) * 0.5),                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case RIGHT_CENTER:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignReference'][widthProperty] - objProperty['alignRightPadding'] - refWidth,                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'] - objProperty['alignBottomPadding'] + ((objProperty['alignReference'][heightProperty] - refHeight) * 0.5),                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case TOP:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignTopPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case BOTTOM:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         y: DisplayObject(objProperty['alignReference']).y + objProperty['alignReference'][heightProperty] - objProperty['alignBottomPadding'] - refHeight,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case LEFT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignLeftPadding'],                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                case RIGHT:                    VSTween.to($target, objProperty['alignDuration'],                                 {                                         x: DisplayObject(objProperty['alignReference']).x + objProperty['alignReference'][widthProperty] - objProperty['alignRightPadding'] - refWidth,                                     delay: objProperty['alignDelay'],                                      ease: objProperty['alignEase']                                 });                    break;                default:                    // do nothing            }        }        /**         * Resizes the target object to the reference object (padding options available, see setFitPadding().         *         * @param $target             Target DisplayObject.         * @param $fitWidth           Option to fit the width of target.         * @param $fitHeight          Option to fit the height of target.         * @param $maintainProportion Option to maintain dimension proportion.         * @param $autoFit            Option to fit target automatically when stage resizes.         * @param $fitReference       reference DisplayObject to fit target against (defaults to stage).         */        public static function setFit($target:DisplayObject, $fitWidth:Boolean = true, $fitHeight:Boolean = true, $maintainProportion:Boolean = false, $autoFit:Boolean = false, $fitReference:DisplayObject = null):void        {            _registerObject($target);            var target:Object       = _dictionary[$target];            var offsetWidth:Number  = target['fitLeftPadding'] + target['fitRightPadding'];            var offsetHeight:Number = target['fitTopPadding'] + target['fitBottomPadding'];            target['fitWidth']           = $fitWidth;            target['fitHeight']          = $fitHeight;            target['maintainProportion'] = $maintainProportion;            setAutoFit($target, $autoFit);            if ($fitReference == null) target['fitReference'] = _stage;            if (target['fitReference'] == _stage)            {                if (target['maintainProportion'])                {                    var targetRatio:Number = $target.width / $target.height;                    var stageRatio:Number = (_stage.stageWidth - offsetWidth) / (_stage.stageHeight - offsetHeight);                    if ($fitWidth && $fitHeight)                    {                        if (stageRatio > targetRatio)                        {                            $target.width  = _stage.stageWidth - offsetWidth;                            $target.height = $target.width / targetRatio;                        }                        else                        {                            $target.height = _stage.stageHeight - offsetHeight;                            $target.width  = $target.height * targetRatio;                        }                    }                    else if ($fitWidth && !$fitHeight)                    {                        $target.width  = _stage.stageWidth - offsetWidth;                        $target.height = $target.width / targetRatio;                    }                    else if (!$fitWidth && $fitHeight)                    {                        $target.height = _stage.stageHeight - offsetHeight;                        $target.width  = $target.height * targetRatio;                    }                }                else                {                    //if (target['fitWidth'] && target['fitHeight']) setAlign($target, TOP_LEFT, true);                    if ($fitWidth)  $target.width  = _stage.stageWidth - offsetWidth;                    if ($fitHeight) $target.height = _stage.stageHeight - offsetHeight;                }            }            else            {                target['fitReference'] = $fitReference;                if ($fitWidth)  $target.width  = $fitReference.width - offsetWidth;                if ($fitHeight) $target.height = $fitReference.height - offsetHeight;            }        }        /**         * Sets target object to auto-align to reference object.         *         * @param  $target     Target DisplayObject.         * @param  $autoAlign  True to auto-align, false to not auto-align.         */        public static function setAutoAlign($target:DisplayObject, $autoAlign:Boolean):void        {            _registerObject($target);            if ($autoAlign)            {                _dictionary[$target]['autoAlign'] = true;                if (_autoAlignedObjects == null)                {                    _autoAlignedObjects = new Array();                    _stage.addEventListener(Event.RESIZE, _onResizeForAlign, false, 5, true);                }                if (_autoAlignedObjects.indexOf($target) == -1)                    _autoAlignedObjects.push($target);            }            else            {                _dictionary[$target]['autoAlign'] = false;                if (_autoAlignedObjects != null && _autoAlignedObjects.indexOf($target) != -1)                {                    _autoAlignedObjects.splice(_autoAlignedObjects.indexOf($target), 1);                    if (_autoAlignedObjects.length == 0)                    {                        _autoAlignedObjects = null;                        _stage.removeEventListener(Event.RESIZE, _onResizeForAlign);                    }                }            }        }        /**         * Sets target object to auto fit to reference object.         *         * @param  $target     Target DisplayObject.         * @param  $autoFit    True to auto fit, false to not auto fit.         */        public static function setAutoFit($target:DisplayObject, $autoFit:Boolean):void        {            _registerObject($target);            if ($autoFit)            {                _dictionary[$target]['autoFit'] = true;                if (_autoFittedObjects == null)                {                    _autoFittedObjects = new Array();                    _stage.addEventListener(Event.RESIZE, _onResizeForFit, false, 6, true);                }                if (_autoFittedObjects.indexOf($target) == -1)                    _autoFittedObjects.push($target);            }            else            {                _dictionary[$target]['autoFit'] = false;                if (_autoFittedObjects.indexOf($target) != -1)                {                    _autoFittedObjects.splice(_autoFittedObjects.indexOf($target), 1);                    if (_autoFittedObjects.length == 0)                    {                        _autoFittedObjects = null;                        _stage.removeEventListener(Event.RESIZE, _onResizeForFit);                    }                }            }        }        /**         * @private         *         * Registers target object in Director dictionary. This will generate all default properties for         * alignment and fitting.         *         * @param $target         *         * @return <code>true</code> on success, <code>false</code> on failure.         */        private static function _registerObject($target:DisplayObject):Boolean        {            // object is already registered            if (_dictionary[$target] != null) return false;            _dictionary[$target] = new Object();            _updateDictionaryAlignSettings($target);            _updateDictionaryFitSettings($target);            $target.addEventListener(Event.REMOVED_FROM_STAGE, _onDirectedObjectRemovedFromStage, false, 0, true);            return true;        }        /**         * @private         *         * Deregisters target object from Director dictionary. This will clear alignment and fitting         * properties associated with the target object along with other garbage collecting routines.         *         * @param $target         *         * @return <code>true</code> on success, <code>false</code> on failure.         */        private static function _deregisterObject($target:DisplayObject):Boolean        {            // object was never registered            if (_dictionary[$target] == null) return false;            if (_dictionary[$target]['autoAlign'])            {                setAutoAlign($target, false);            }            if (_dictionary[$target]['autoFit'])            {                setAutoFit($target, false);            }            delete _dictionary[$target];            $target.removeEventListener(Event.REMOVED_FROM_STAGE, _onDirectedObjectRemovedFromStage);            return true;        }        /**         * @private         *         * Generates default align properties for the registered object.         *         * @param $target         */        private static function _updateDictionaryAlignSettings($target:DisplayObject):void        {            _dictionary[$target]['alignTopPadding']    = DEFAULT_TOP_PADDING;            _dictionary[$target]['alignRightPadding']  = DEFAULT_RIGHT_PADDING;            _dictionary[$target]['alignBottomPadding'] = DEFAULT_BOTTOM_PADDING;            _dictionary[$target]['alignLeftPadding']   = DEFAULT_LEFT_PADDING;            _dictionary[$target]['alignType']          = DEFAULT_ALIGN;            _dictionary[$target]['alignReference']     = _stage;            _dictionary[$target]['autoAlign']          = false;            _dictionary[$target]['pivotWidth']         = NaN;            _dictionary[$target]['pivotHeight']        = NaN;            _dictionary[$target]['alignAnimated']      = DEFAULT_ANIMATED;            _dictionary[$target]['alignDuration']      = DEFAULT_DURATION;            _dictionary[$target]['alignDelay']         = DEFAULT_DELAY;            _dictionary[$target]['alignEase']          = Quart.easeOut;        }        /**         * @private         *         * Generates default fit properties for the registered object.         *         * @param $target         */        private static function _updateDictionaryFitSettings($target:DisplayObject):void        {            _dictionary[$target]['fitTopPadding']      = DEFAULT_TOP_PADDING;            _dictionary[$target]['fitRightPadding']    = DEFAULT_RIGHT_PADDING;            _dictionary[$target]['fitBottomPadding']   = DEFAULT_BOTTOM_PADDING;            _dictionary[$target]['fitLeftPadding']     = DEFAULT_LEFT_PADDING;            _dictionary[$target]['fitReference']       = _stage;            _dictionary[$target]['fitWidth']           = false;            _dictionary[$target]['fitHeight']          = false;            _dictionary[$target]['autoFit']            = false;            _dictionary[$target]['maintainProportion'] = false;        }        /**         * @private         *         * flash.events.Event.RESIZE handler for registered objects marked for auto-alignment.         *         * @param $event         */        private static function _onResizeForAlign($event:Event):void        {            for (var i:int = 0; i < _autoAlignedObjects.length; i++)            {                var target:Object = _dictionary[_autoAlignedObjects[i]];                setAlign(_autoAlignedObjects[i], target['alignType'], true, target['pivotWidth'], target['pivotHeight'], target['alignReference'], target['alignAnimated'], target['alignDuration'], target['alignDelay'], target['alignEase']);            }        }        /**         * @private         *         * flash.events.Event.RESIZE handler for registered objects marked for auto fitting.         *         * @param $event         */        private static function _onResizeForFit($event:Event):void        {            for (var i:Object in _autoFittedObjects)            {                var target:Object = _dictionary[_autoFittedObjects[i]];                setFit(_autoFittedObjects[i], target['fitWidth'], target['fitHeight'], target['maintainProportion'], true, target['fitReference']);            }        }        /**         * @private         *         * Event.REMOVED_FROM_STAGE handler used for garbage collecting registered objects.         *         * @param $event         */        private static function _onDirectedObjectRemovedFromStage($event:Event):void        {            var target:DisplayObject = $event.target as DisplayObject;            _deregisterObject(target);        }    }}